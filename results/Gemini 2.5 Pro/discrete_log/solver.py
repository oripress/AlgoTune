import math
from typing import Any, Dict

class Solver:
    def solve(self, problem: Dict[str, int], **kwargs: Any) -> Dict[str, int]:
        """
        Solves the discrete logarithm problem using the Baby-Step Giant-Step algorithm.
        g^x â‰¡ h (mod p)
        """
        p = problem["p"]
        g = problem["g"]
        h = problem["h"]

        # The order of the group is p-1, assuming g is a generator of the full group.
        n = p - 1
        m = int(math.sqrt(n)) + 1

        # Baby steps: store {g^j mod p: j} for j in [0, m-1]
        baby_steps = {}
        val = 1
        for j in range(m):
            if val not in baby_steps:
                baby_steps[val] = j
            val = (val * g) % p

        # Giant steps: find i such that h * (g^-m)^i is in baby_steps
        # We need g^(-m) mod p.
        # This is equivalent to (g^m)^-1 mod p.
        g_m = pow(g, m, p)
        try:
            g_inv_m = pow(g_m, -1, p)
        except ValueError:
            # This can happen if g_m is not invertible mod p.
            # For a prime p, this would mean g_m % p == 0.
            # This shouldn't happen if g is a valid generator.
            # Fallback or error. For now, we assume valid inputs.
            # A more robust solution might be needed if this path is taken.
            return {"x": -1} # Should indicate failure

        # Search for a match
        # h * (g^-m)^i = g^j  =>  h = g^(i*m + j)
        giant_step_val = h
        for i in range(m):
            if giant_step_val in baby_steps:
                j = baby_steps[giant_step_val]
                x = i * m + j
                return {"x": x}
            giant_step_val = (giant_step_val * g_inv_m) % p

        # No solution found. This might happen if h is not in the subgroup generated by g,
        # or if the order of g is smaller than assumed.
        return {"x": -1} # Should indicate failure