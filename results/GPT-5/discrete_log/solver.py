from __future__ import annotations

from typing import Any, Dict, Tuple, Optional
import math
import random

try:
    # Optional accelerated factorization and fallback DLP solver
    from sympy.ntheory import factorint as sympy_factorint  # type: ignore
except Exception:  # pragma: no cover
    sympy_factorint = None  # type: ignore

try:
    from sympy.ntheory.residue_ntheory import discrete_log as sympy_discrete_log  # type: ignore
except Exception:  # pragma: no cover
    sympy_discrete_log = None  # type: ignore

class Solver:
    def solve(self, problem, **kwargs) -> Any:
        """
        Solve g^x ≡ h (mod p) for prime p using a fast hybrid approach:
        - Early trivial checks
        - Try Pohlig–Hellman by factoring p-1, solving each prime power using BSGS
          for small factors and Pollard Rho for large ones
        - Combine results via CRT
        - Robust fallbacks to sympy's discrete_log if needed
        """
        p = int(problem["p"])
        g = int(problem["g"]) % p
        h = int(problem["h"]) % p

        # Trivial cases
        if p == 2:
            return {"x": 0}
        if h == 1:
            return {"x": 0}

        # Group order
        N = p - 1

        # If the group order is small enough, a direct BSGS is very fast and avoids factorization overhead
        # Threshold chosen to keep memory moderate (m ~ sqrt(N) up to ~50k entries)
        m = int(math.isqrt(N)) + 1
        if m <= 50_000:
            x_bsgs = bsgs_general(p, g, h, N)
            if x_bsgs is not None:
                return {"x": int(x_bsgs)}

        # Factor p-1 to compute ord(g) and use Pohlig–Hellman
        factors = factorize(N)

        # Compute ord(g) dividing N
        ord_g = N
        for q, e in factors.items():
            for _ in range(e):
                t = ord_g // q
                if pow(g, t, p) == 1:
                    ord_g = t
                else:
                    break

        # If g has order 1 then only h==1 has solution (handled above)
        if ord_g == 1:
            return {"x": 0}

        # Check that h is in subgroup generated by g
        if pow(h, ord_g, p) != 1:
            # No solution in subgroup; for valid tasks this shouldn't happen
            # Fall back to sympy if available for definitive answer
            if sympy_discrete_log is not None:
                try:
                    x = int(sympy_discrete_log(p, h, g))
                    return {"x": x}
                except Exception:
                    return {"x": 0}
            return {"x": 0}

        # Extract factorization of ord_g from factors of N
        ord_factors: Dict[int, int] = {}
        tmp = ord_g
        for q in factors.keys():
            if tmp % q == 0:
                cnt = 0
                while tmp % q == 0:
                    tmp //= q
                    cnt += 1
                ord_factors[q] = cnt
        if tmp != 1:
            ord_factors[tmp] = ord_factors.get(tmp, 0) + 1

        residues = []
        moduli = []

        # Deterministic RNG seed based on problem values for Pollard rho
        seed_base = (p ^ (g << 1) ^ (h << 2)) & ((1 << 61) - 1)

        # Solve modulo each prime power
        for q, e in ord_factors.items():
            n_i = q ** e
            exp = ord_g // n_i
            a = pow(g, exp, p)  # element of order n_i
            b = pow(h, exp, p)

            # Solve a^x ≡ b (mod p), x in [0, n_i-1]
            x_i = discrete_log_cyclic(p=p, a=a, b=b, n=n_i,
                                      seed=(seed_base + q + (e << 7)) & ((1 << 61) - 1))
            if x_i is None:
                # As a fallback, try again with different seed
                x_i = discrete_log_cyclic(p=p, a=a, b=b, n=n_i,
                                          seed=(seed_base + 0x9E3779B97F4A7C15 + q) & ((1 << 61) - 1))
            if x_i is None and sympy_discrete_log is not None:
                # Last resort: sympy restricted to subgroup of order n_i
                try:
                    x_i = int(sympy_discrete_log(p, b, a, order=n_i))
                except Exception:
                    x_i = None
            if x_i is None:
                # If still None, fall back to global sympy call for reliability
                if sympy_discrete_log is not None:
                    try:
                        x = int(sympy_discrete_log(p, h, g, order=ord_g))
                        return {"x": x}
                    except Exception:
                        return {"x": 0}
                return {"x": 0}

            residues.append(x_i)
            moduli.append(n_i)

        # Combine via CRT
        x = crt_pairwise(residues, moduli)
        x %= ord_g

        # Defensive verification; if mismatch (shouldn't happen), fall back to sympy
        if pow(g, x, p) != h:
            if sympy_discrete_log is not None:
                try:
                    x = int(sympy_discrete_log(p, h, g, order=ord_g))
                    return {"x": x}
                except Exception:
                    pass
        return {"x": int(x)}

def factorize(n: int) -> Dict[int, int]:
    """
    Factor integer n using sympy's factorint if available, else simple trial division fallback.
    """
    if n <= 1:
        return {}
    if sympy_factorint is not None:
        try:
            return dict(sympy_factorint(n))
        except Exception:
            pass
    # Fallback: simple trial division (sufficient for small/medium cases)
    res: Dict[int, int] = {}
    m = n
    # remove 2s
    cnt2 = 0
    while m % 2 == 0:
        m //= 2
        cnt2 += 1
    if cnt2:
        res[2] = cnt2
    d = 3
    while d * d <= m:
        if m % d == 0:
            cnt = 0
            while m % d == 0:
                m //= d
                cnt += 1
            res[d] = cnt
        d += 2
    if m > 1:
        res[m] = res.get(m, 0) + 1
    return res

def inv_mod(a: int, m: int) -> int:
    """
    Modular inverse of a modulo m, raises ValueError if not invertible.
    """
    a %= m
    if a == 0:
        raise ValueError("Inverse does not exist")
    try:
        return pow(a, -1, m)
    except ValueError:
        g, x, _ = extended_gcd(a, m)
        if g != 1:
            raise ValueError("Inverse does not exist")
        return x % m

def extended_gcd(a: int, b: int) -> Tuple[int, int, int]:
    """
    Returns (g, x, y) such that a*x + b*y = g = gcd(a, b)
    """
    old_r, r = a, b
    old_s, s = 1, 0
    old_t, t = 0, 1
    while r:
        q = old_r // r
        old_r, r = r, old_r - q * r
        old_s, s = s, old_s - q * s
        old_t, t = t, old_t - q * t
    return old_r, old_s, old_t

def solve_linear_mod(b: int, c: int, n: int) -> Optional[Tuple[int, int]]:
    """
    Solve b*x ≡ c (mod n). Returns (x0, mod) meaning x ≡ x0 (mod mod).
    If no solution, returns None.
    """
    b %= n
    c %= n
    if c == 0 and b == 0:
        return 0, 1
    g, x, _ = extended_gcd(b, n)
    if c % g != 0:
        return None
    n_g = n // g
    x0 = (x * (c // g)) % n_g
    return x0, n_g  # solutions x ≡ x0 mod n_g

def crt_pairwise(residues: list[int], moduli: list[int]) -> int:
    """
    Solve system x ≡ residues[i] (mod moduli[i]) for coprime moduli via pairwise CRT.
    Assumes moduli are pairwise coprime (prime powers of distinct primes).
    """
    x = 0
    m = 1
    for (r, mod) in zip(residues, moduli):
        k = ((r - x) % mod) * inv_mod(m % mod, mod) % mod
        x += m * k
        m *= mod
    return x % m

def brute_force_dlog(p: int, a: int, b: int, n: int) -> Optional[int]:
    """
    Brute force discrete log for very small n.
    """
    cur = 1
    if b == 1:
        return 0
    for x in range(1, n + 1):
        cur = (cur * a) % p
        if cur == b:
            return x
    return None

def bsgs(a: int, b: int, p: int, n: int) -> Optional[int]:
    """
    Baby-step Giant-step to solve a^x ≡ b (mod p) with x in [0, n-1].
    Returns the smallest x if found, else None.
    """
    if n <= 64:
        return brute_force_dlog(p, a, b, n)

    m = int(math.isqrt(n)) + 1

    # Baby steps: a^j
    table: Dict[int, int] = {}
    aj = 1
    for j in range(m):
        # only store first index for a given value
        if aj not in table:
            table[aj] = j
        aj = (aj * a) % p

    # factor = a^{-m} mod p
    am = aj  # aj currently equals a^m
    try:
        factor = inv_mod(am, p)
    except ValueError:
        return None

    # Giant steps: b * (a^{-m})^i
    gamma = b % p
    for i in range(m + 1):
        j = table.get(gamma)
        if j is not None:
            x = i * m + j
            if x < n:
                return x
            x %= n
            if pow(a, x, p) == b:
                return x
        gamma = (gamma * factor) % p
    return None

def pollard_rho_dlog(p: int, a: int, b: int, n: int, seed: int, max_tries: int = 12) -> Optional[int]:
    """
    Pollard's Rho for discrete log in cyclic group of order n (subgroup of F_p*).
    Returns x in [0, n-1] or None if failure.
    """
    # Partition function with 3 sets
    def f(X: int, A: int, B: int) -> Tuple[int, int, int]:
        r = X % 3
        if r == 0:
            X = (X * a) % p
            A = (A + 1) % n
        elif r == 1:
            X = (X * b) % p
            B = (B + 1) % n
        else:
            X = (X * X) % p
            A = (A << 1) % n
            B = (B << 1) % n
        return X, A, B

    isqrt_n = int(math.isqrt(n))
    # heuristic cap per try
    iter_cap = max(1000, 6 * isqrt_n + 100)

    for t in range(max_tries):
        rnd = random.Random((seed + 0x9E3779B97F4A7C15 * (t + 1)) & ((1 << 64) - 1))
        A = rnd.randrange(n)
        B = rnd.randrange(n)
        X = (pow(a, A, p) * pow(b, B, p)) % p

        X1, A1, B1 = f(X, A, B)
        X2, A2, B2 = f(*f(X, A, B))

        steps = 0
        while X1 != X2 and steps < iter_cap:
            X1, A1, B1 = f(X1, A1, B1)
            X2, A2, B2 = f(*f(X2, A2, B2))
            steps += 1

        if X1 != X2:
            # try next restart
            continue

        # Collision: a^{A1} b^{B1} = a^{A2} b^{B2}
        u = (A1 - A2) % n
        v = (B2 - B1) % n  # note order to get v*x ≡ u (mod n)

        if v == 0:
            # Unusable collision, restart
            continue

        sol = solve_linear_mod(v, u, n)
        if sol is None:
            continue
        x0, mod = sol  # x ≡ x0 (mod mod)

        # Verify and refine if necessary (when gcd(v, n) > 1)
        limit = min(n // mod, 16)  # if too many possibilities, try a few
        for k in range(limit):
            x_candidate = (x0 + k * mod) % n
            if pow(a, x_candidate, p) == b:
                return x_candidate
        # Restart if failed
    return None

def discrete_log_cyclic(p: int, a: int, b: int, n: int, seed: int) -> Optional[int]:
    """
    Solve a^x ≡ b (mod p) where a has order exactly n (subgroup of F_p*).
    Try small-n brute force, then BSGS, and Pollard's rho as fallback for large n.
    """
    a %= p
    b %= p
    if b == 1:
        return 0
    if n <= 64:
        return brute_force_dlog(p, a, b, n)

    # Thresholds: adjust for speed/memory
    BSGS_LIMIT = 120_000  # limit on m to cap memory
    if n <= BSGS_LIMIT * BSGS_LIMIT:
        x = bsgs(a, b, p, n)
        if x is not None:
            return x

    # Pollard's rho fallback for larger n
    x = pollard_rho_dlog(p, a, b, n, seed=seed)
    if x is not None:
        return x

    # Final fallback to sympy if available
    if sympy_discrete_log is not None:
        try:
            return int(sympy_discrete_log(p, b, a, order=n))
        except Exception:
            return None
    return None

def bsgs_general(p: int, g: int, h: int, n: int) -> Optional[int]:
    """
    General BSGS without knowing ord(g): finds x with g^x ≡ h (mod p), 0 <= x < n.
    """
    m = int(math.isqrt(n)) + 1

    table: Dict[int, int] = {}
    e = 1
    for j in range(m):
        if e not in table:
            table[e] = j
        e = (e * g) % p

    try:
        factor = inv_mod(pow(g, m, p), p)
    except ValueError:
        return None

    gamma = h % p
    for i in range(m + 1):
        j = table.get(gamma)
        if j is not None:
            x = i * m + j
            if x < n and pow(g, x, p) == h:
                return x
        gamma = (gamma * factor) % p
    return None