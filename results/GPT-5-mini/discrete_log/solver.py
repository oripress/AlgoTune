import math
import random
from typing import Any, Dict, List, Tuple

# Try to use sympy's factorint for reliable factoring; fall back to simple trial division if not available.
try:
    from sympy import factorint  # type: ignore
except Exception:  # pragma: no cover - fallback if sympy isn't present
    factorint = None  # type: ignore

class Solver:
    def solve(self, problem: Dict[str, int], **kwargs) -> Dict[str, int]:
        """
        Solve discrete logarithm g^x ≡ h (mod p) for x using Pohlig-Hellman
        combined with baby-step/giant-step for prime-power factors.

        Expects p to be prime (as per problem statement). Returns x in [0, order-1]
        where order is multiplicative order of g modulo p.
        """
        p = int(problem["p"])
        g = int(problem["g"]) % p
        h = int(problem["h"]) % p

        # trivial cases
        if p == 2:
            # modulo 2, group has order 1, only element 1
            return {"x": 0}
        if h == 1:
            return {"x": 0}
        if g % p == 0:
            # g == 0 (mod p). Only h==0 has solution x>=1; treat as no-solution -> return 0
            return {"x": 0}

        n = p - 1  # group order for multiplicative group modulo prime p

        # Factor n
        fac = self._factor_int(n)

        # Compute multiplicative order of g (divides n)
        ord_g = n
        # iterate primes and remove factors while g^(ord_g/q) == 1
        for q in sorted(fac.keys()):
            while ord_g % q == 0 and pow(g, ord_g // q, p) == 1:
                ord_g //= q

        # If h not in subgroup generated by g, there is no solution.
        if pow(h, ord_g, p) != 1:
            # Return something well-formed; caller will mark invalid if unsolvable.
            return {"x": 0}

        # Factor ord_g (may be smaller than n)
        fac_ord = self._factor_int(ord_g)

        # Solve discrete log modulo each prime power q^e dividing ord_g
        congruences: List[Tuple[int, int]] = []
        for q, e in fac_ord.items():
            pe = q ** e
            x_mod_pe = self._discrete_log_prime_power(g, h, p, ord_g, q, e)
            congruences.append((x_mod_pe % pe, pe))

        # Combine congruences using CRT
        x = self._crt(congruences)
        x %= ord_g
        return {"x": int(x)}

    # -------------------------
    # Utility functions
    # -------------------------
    def _factor_int(self, n: int) -> Dict[int, int]:
        """
        Factor n into prime powers. Prefer sympy.factorint when available for speed/reliability.
        """
        if n <= 1:
            return {}
        if 'factorint' in globals() and globals()["factorint"] is not None:
            fi = globals()["factorint"](n)
            # sympy returns mpz etc., convert to int
            return {int(k): int(v) for k, v in fi.items()}
        # Fallback: trial division + Pollard Rho
        return self._factor_pollard(n)

    def _factor_pollard(self, n: int) -> Dict[int, int]:
        res: Dict[int, int] = {}
        if n <= 1:
            return res
        # trial division small primes
        small = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]
        for sp in small:
            while n % sp == 0:
                res[sp] = res.get(sp, 0) + 1
                n //= sp
        if n == 1:
            return res
        # use recursive Pollard-Rho
        stack = [n]
        while stack:
            m = stack.pop()
            if m == 1:
                continue
            if self._is_probable_prime(m):
                res[m] = res.get(m, 0) + 1
                continue
            d = self._pollards_rho(m)
            if d is None or d == m:
                # treat as prime to avoid infinite loop
                res[m] = res.get(m, 0) + 1
            else:
                stack.append(d)
                stack.append(m // d)
        return res

    def _is_probable_prime(self, n: int) -> bool:
        if n < 2:
            return False
        small = (2, 3, 5, 7, 11, 13, 17, 19, 23, 29)
        for sp in small:
            if n % sp == 0:
                return n == sp
        # Miller-Rabin with deterministic bases for 64-bit and generic fallback
        d = n - 1
        s = 0
        while d % 2 == 0:
            s += 1
            d //= 2

        def check(a: int) -> bool:
            x = pow(a, d, n)
            if x == 1 or x == n - 1:
                return True
            for _ in range(s - 1):
                x = (x * x) % n
                if x == n - 1:
                    return True
            return False

        # choose bases
        if n < 2_152_302_898_747:
            bases = (2, 3, 5, 7, 11)
        elif n < 3_474_749_660_383:
            bases = (2, 3, 5, 7, 11, 13)
        elif n < 341550071728321:
            bases = (2, 3, 5, 7, 11, 13, 17)
        elif n < (1 << 64):
            bases = (2, 325, 9375, 28178, 450775, 9780504, 1795265022)
        else:
            bases = (2, 3, 5, 7, 11, 13, 17, 19, 23)
        for a in bases:
            if a % n == 0:
                continue
            if not check(a):
                return False
        return True

    def _pollards_rho(self, n: int) -> int:
        if n % 2 == 0:
            return 2
        if n % 3 == 0:
            return 3
        # try several times with random parameters
        for _ in range(10):
            x = random.randrange(2, n - 1)
            y = x
            c = random.randrange(1, n - 1)
            d = 1
            while d == 1:
                x = (x * x + c) % n
                y = (y * y + c) % n
                y = (y * y + c) % n
                d = math.gcd(abs(x - y), n)
                if d == n:
                    break
            if 1 < d < n:
                return d
        return None  # fallback

    def _egcd(self, a: int, b: int) -> Tuple[int, int, int]:
        if b == 0:
            return (a, 1, 0)
        else:
            g, x1, y1 = self._egcd(b, a % b)
            x = y1
            y = x1 - (a // b) * y1
            return (g, x, y)

    def _modinv(self, a: int, m: int) -> int:
        g, x, _ = self._egcd(a, m)
        if g != 1:
            raise ValueError("Modular inverse does not exist")
        return x % m

    def _crt(self, congruences: List[Tuple[int, int]]) -> int:
        """
        Combine congruences [(a_i, n_i)] with pairwise coprime n_i.
        Uses incremental CRT.
        """
        x = 0
        M = 1
        for ai, ni in congruences:
            # solve M * t ≡ (ai - x) (mod ni)
            if M % ni == 0:
                # should not happen if moduli are pairwise coprime
                x = ai
                M = ni
                continue
            t = (ai - x) % ni
            inv = self._modinv(M % ni, ni)
            t = (t * inv) % ni
            x = x + M * t
            M *= ni
        return x

    # -------------------------
    # Discrete log per prime-power (Pohlig-Hellman inner)
    # -------------------------
    def _discrete_log_prime_power(self, g: int, h: int, p: int, ord_g: int, q: int, e: int) -> int:
        """
        Compute x modulo q^e where ord_g divides group order and q^e | ord_g.
        Returns integer x in [0, q^e - 1].
        """
        pe = q ** e
        x = 0
        cur = 1  # g^x mod p, keeps track of known part
        # Use constant base a = g^{ord_g//q} for extracting each q-ary digit.
        a = pow(g, ord_g // q, p)
        # g_qk will hold g^{q^k} to update cur efficiently
        g_qk = g % p  # g^{1} for k=0
        for k in range(e):
            # exponent to reduce the problem to order q
            exp = ord_g // (q ** (k + 1))
            # rhs = (h * cur^{-1})^{exp} mod p
            inv_cur = pow(cur, p - 2, p)
            rhs = pow((h * inv_cur) % p, exp, p)
            # solve a^y = rhs for y in [0, q-1], where a = g^{ord_g//q}
            y = self._bsgs(a, rhs, p, order_bound=q)
            if y is None:
                y = 0
            x += y * (q ** k)
            # update cur *= g^{y * q^k}
            cur = (cur * pow(g_qk, y, p)) % p
            # prepare g_qk for next k: g^{q^{k+1}} = (g^{q^k})^q
            g_qk = pow(g_qk, q, p)
        return x

    def _bsgs(self, a: int, b: int, mod: int, order_bound: int = None) -> int:
        """
        Baby-step Giant-step discrete log: find x such that a^x ≡ b (mod mod).
        If order_bound is given, search modulo that order (x < order_bound).
        Returns integer x or None if not found.
        """
        a %= mod
        b %= mod
        if b == 1:
            return 0
        if a == 0:
            return 0 if b == 0 else None
        if order_bound is None:
            order = mod - 1
        else:
            order = int(order_bound)
        m = int(math.isqrt(order)) + 1
        baby: Dict[int, int] = {}
        aj = 1
        for j in range(m):
            # only keep the first (smallest) j for a given value
            if aj not in baby:
                baby[aj] = j
            aj = (aj * a) % mod
        factor = pow(a, m, mod)
        # compute inverse of factor modulo mod (mod is prime here in our use-cases)
        try:
            inv_factor = pow(factor, -1, mod)
        except TypeError:
            inv_factor = self._modinv(factor, mod)
        gamma = b
        for i in range(m + 1):
            if gamma in baby:
                ans = i * m + baby[gamma]
                if order_bound is not None:
                    ans %= order_bound
                return ans
            gamma = (gamma * inv_factor) % mod
        return None