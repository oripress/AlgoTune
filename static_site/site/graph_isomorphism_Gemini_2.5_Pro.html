<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>AlgoTuner Log – graph_isomorphism – Gemini 2.5 Pro</title>
    <link rel="icon" type="image/png" href="assets/AlgoTunerMascot.png">
    
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-7XSBWH5NQF"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-7XSBWH5NQF');
    </script>
    
    <!-- Prism.js for syntax highlighting - loaded after styles.css to ensure proper precedence -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
    <link rel="stylesheet" href="styles.css">"
    
    <!-- Basic Styling & Layout -->
    <style>
    /* Basic Styling & Layout */
    :root {
        --primary-color: #2196F3;
        --primary-light: #E3F2FD;
        --text-color: #333;
        --border-color: #eaeaea;
        --content-bg: #ffffff;
        --error-border: #dc3545;
        --code-bg: #f6f8fa;
        --code-border: #d0d7de;
        --code-text: #24292e;
        
        /* Glass-morphism variables for light mode */
        --glass-bg: rgba(255, 255, 255, 0.12);
        --glass-border: rgba(255, 255, 255, 0.05);
        --glass-header-bg: rgba(0, 0, 0, 0.03);
        --glass-header-border: rgba(255, 255, 255, 0.08);
        --glass-btn-bg: rgba(255, 255, 255, 0.1);
        --glass-btn-border: rgba(255, 255, 255, 0.2);
        --glass-btn-hover: rgba(255, 255, 255, 0.2);
        --glass-expand-bg: linear-gradient(to top, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.8));
        --glass-text: rgba(0, 0, 0, 0.8);
        --glass-text-secondary: rgba(0, 0, 0, 0.6);
    }
    
    /* Dark mode support */
    @media (prefers-color-scheme: dark) {
        :root {
            --glass-bg: rgba(0, 0, 0, 0.15);
            --glass-border: rgba(255, 255, 255, 0.08);
            --glass-header-bg: rgba(255, 255, 255, 0.05);
            --glass-header-border: rgba(255, 255, 255, 0.12);
            --glass-btn-bg: rgba(255, 255, 255, 0.08);
            --glass-btn-border: rgba(255, 255, 255, 0.15);
            --glass-btn-hover: rgba(255, 255, 255, 0.15);
            --glass-expand-bg: linear-gradient(to top, rgba(0, 0, 0, 0.85), rgba(0, 0, 0, 0.7));
            --glass-text: rgba(255, 255, 255, 0.9);
            --glass-text-secondary: rgba(255, 255, 255, 0.7);
        }
    }
    
    body {
        margin: 0;
        padding: 0;
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        color: var(--text-color);
        line-height: 1.5;
        background: var(--content-bg);
        display: flex;
        min-height: 100vh;
    }
    
    /* Sidebar - Desktop only, hidden by default on mobile */
    .sidebar {
        /* Slightly narrower sidebar to give more room to main content */
        width: 180px;
        background: #f8f9fa;
        border-right: 1px solid var(--border-color);
        position: fixed;
        left: 0;
        top: 0;
        height: 100vh;
        overflow-y: auto;
        z-index: 1000;
        display: none; /* Hidden by default */
    }
    
    /* Show sidebar only on large screens (1025px and up) */
    @media (min-width: 1025px) {
        .sidebar {
            display: block;
        }
    }
    
    /* --------------------------- */
    /* Sidebar header & back link  */
    /* --------------------------- */
    .sidebar-header {
        padding: 1.25rem;
        display: flex;
        justify-content: center;  /* Centre the back link horizontally */
    }

    .back-link {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;               /* Space between arrow and label */
        padding: 0.45rem 0.9rem;
        background: #2196F3;       /* Primary blue */
        border-radius: 8px;
        color: #ffffff;            /* White text */
        font-weight: 600;
        font-size: 0.9rem;
        text-decoration: none;
        transition: background 0.2s ease, box-shadow 0.2s ease;
    }

    .back-link:hover {
        background: #1976D2;       /* Darker blue on hover */
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
        text-decoration: none; 
        color: #ffffff;
    }
    
    .sidebar-content {
        padding: 1rem;
    }
    
    .sidebar-content h3 {
        margin: 0 0 1rem 0;
        font-size: 1rem;
        color: var(--text-color);
        text-align: left;
        /* Allow long task names with underscores to wrap onto multiple lines */
        white-space: normal;
        word-wrap: break-word;
        overflow-wrap: anywhere;
        line-height: 1.3;
    }
    
    .sidebar-task {
        margin-bottom: 1.5rem;
    }
    
    .task-name {
        font-weight: 600;
        font-size: 0.85rem;
        color: var(--primary-color);
        margin-bottom: 0.5rem;
        padding: 0.25rem 0;
        border-bottom: 1px solid #e0e0e0;
        /* Allow very long task names to wrap instead of overflowing */
        white-space: normal;
        word-wrap: break-word;
        overflow-wrap: anywhere;
        line-height: 1.3;
    }
    
    .sidebar-run {
        margin-bottom: 8px;
    }
    
    /* Make sidebar run links occupy full width */
    .sidebar-run a {
        display: block;
        width: 100%;
        text-decoration: none;
    }
    
    .sidebar-run a:hover, .sidebar-run a:focus, .sidebar-run a:visited {
        text-decoration: none;
    }
    
    /* Ensure the coloured badge stretches the whole column */
    .run-score {
        width: 100%;
    }
    
    /* Thicker highlight for the currently selected run on desktop */
    @media (min-width: 769px) {
        .sidebar-run.current a {
            border-left: 5px solid #2196F3 !important;
        }
    }
    
    .main-content {
        flex: 1;
        margin-left: 180px;
        padding: 0;
        max-width: calc(100vw - 180px);
    }
    
    .container {
        /* Allow the main conversation area to take up the full width that is
           available once the fixed sidebar is accounted for. */
        max-width: 100%;
        margin: 0 auto;
        padding: 0 15px;
    }
    
    h1 {
        color: var(--primary-color);
        border-bottom: 2px solid var(--primary-light);
        padding-bottom: 0.5rem;
    }
    
    .info-section {
        background: var(--primary-light);
        padding: 1rem;
        border-radius: 6px;
        margin-bottom: 1.5rem;
        display: flex;
        flex-wrap: nowrap;
        gap: 1rem;
        overflow-x: auto;
        white-space: nowrap;
    }
    
    .info-item {
        display: flex;
        flex-direction: column;
        flex-shrink: 0;
        min-width: 140px;
    }
    
    .info-label {
        font-weight: 600;
        color: var(--primary-color);
        font-size: 0.85rem;
        margin-bottom: 0.25rem;
        white-space: nowrap;
    }
    
    .info-value {
        font-size: 0.9rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    
    .task-info-line, .model-info-line {
        font-size: 1.3rem;
        word-wrap: break-word;
        overflow-wrap: break-word;
        text-align: left !important;
        display: block;
    }
    
    .task-name-display {
        font-weight: 600;
        font-size: clamp(0.9rem, 4vw, 1.3rem);
        word-wrap: break-word;
        overflow-wrap: break-word;
        line-height: 1.2;
    }
    
    .plots-container {
        display: flex;
        gap: 1rem;
        margin: 1.5rem 0;
    }
    
    .plot-section {
        margin: 0;
    }
    
    .plot-half {
        flex: 1;
        width: 50%;
    }
    
    .plot-section h3 {
        margin-bottom: 0.8rem;
        color: var(--text-color);
    }
    
    .plot-container {
        text-align: center;
        background: #ffffff;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        padding: 1rem;
        margin-bottom: 1rem;
    }
    
    .plot-container img {
        max-width: 100%;
        height: auto;
        display: block;
        margin: 0 auto;
    }
    
    .no-plot {
        color: #666;
        font-style: italic;
        padding: 2rem;
        text-align: center;
    }
    
    .conversation-section {
        margin: 1.5rem 0;
    }
    
    .message {
        margin-bottom: 1rem;
        padding: 1rem;
        border-radius: 18px;
        /* Give the chat bubbles more breathing room. 90 % looks good on both
           desktop and tablet while still leaving a small margin on the side. */
        max-width: 90%;
        position: relative;
    }
    
    .message.system {
        background: #e5e5ea;
        color: #000;
        margin-left: auto;
        margin-right: 0;
        border-radius: 18px 18px 4px 18px;
    }
    
    .message.assistant {
        background: #007aff;
        color: white;
        margin-left: 0;
        margin-right: auto;
        border-radius: 18px 18px 18px 4px;
    }
    
    .message-header {
        font-weight: 600;
        margin-bottom: 0.5rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    
    .command-badge {
        background: rgba(0, 0, 0, 0.2);
        color: inherit;
        padding: 0.2rem 0.5rem;
        border-radius: 12px;
        font-size: 0.75rem;
        font-weight: 500;
        opacity: 0.8;
    }
    
    .message.system .command-badge {
        background: rgba(0, 0, 0, 0.15);
        color: #000;
    }
    
    .message.assistant .command-badge {
        background: rgba(255, 255, 255, 0.25);
        color: white;
    }
    
    /* Premium Glass-Morphism Code Block Container */
    .code-block {
        position: relative;
        margin: clamp(1.5rem, 2vw, 2rem) 0;
        border-radius: clamp(12px, 3vw, 20px);
        padding: 0;
        overflow: hidden;
        max-width: 100%;
        box-sizing: border-box;
        
        /* Glass-morphism backdrop effects */
        background: var(--code-bg);
        backdrop-filter: blur(16px);
        -webkit-backdrop-filter: blur(16px);
        
        /* Multi-layer shadows for depth */
        box-shadow: 
            0 8px 32px rgba(0, 0, 0, 0.12),
            0 2px 8px rgba(0, 0, 0, 0.08),
            inset 0 1px 0 rgba(255, 255, 255, 0.15),
            0 0 0 1px var(--code-border);
        
        /* Smooth animations */
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .code-block:hover {
        transform: translateY(-2px);
        box-shadow: 
            0 12px 40px rgba(0, 0, 0, 0.16),
            0 4px 12px rgba(0, 0, 0, 0.12),
            inset 0 1px 0 rgba(255, 255, 255, 0.2),
            0 0 0 1px rgba(255, 255, 255, 0.08);
    }
    
    /* Code Block Header with Copy Button */
    .code-block-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: clamp(0.75rem, 2vw, 1rem) clamp(1rem, 3vw, 1.5rem);
        background: var(--glass-header-bg);
        border-bottom: 1px solid var(--glass-header-border);
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
    }
    
    .code-language-tag {
        font-size: clamp(0.7rem, 1.5vw, 0.75rem);
        font-weight: 600;
        color: var(--glass-text-secondary);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', system-ui, sans-serif;
    }
    
    .code-copy-btn {
        padding: clamp(0.4rem, 1vw, 0.5rem) clamp(0.6rem, 1.5vw, 0.8rem);
        background: var(--glass-btn-bg);
        border: 1px solid var(--glass-btn-border);
        border-radius: clamp(6px, 1.5vw, 8px);
        color: var(--glass-text-secondary);
        font-size: clamp(0.7rem, 1.5vw, 0.75rem);
        font-weight: 500;
        cursor: pointer;
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        touch-action: manipulation;
        user-select: none;
        font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', system-ui, sans-serif;
    }
    
    .code-copy-btn:hover {
        background: var(--glass-btn-hover);
        border-color: var(--glass-btn-border);
        transform: scale(1.02);
    }
    
    .code-copy-btn:active {
        transform: scale(0.98);
    }
    
    .code-copy-btn.copied {
        background: rgba(16, 185, 129, 0.15);
        border-color: rgba(16, 185, 129, 0.3);
        color: #059669;
    }
    
    /* Code Content Container */
    .code-content {
        position: relative;
        overflow: hidden;
    }
    
    /* Code Block Content (pre/code tags) */
    .code-block pre, .code-block code {
        margin: 0;
        padding: 0;
        background: none !important;
        font-family: 'SF Mono', 'Fira Code', 'Menlo', 'Consolas', monospace;
        font-size: clamp(0.8rem, 2vw, 0.85rem);
        line-height: 1.6;
        color: var(--code-text);
        text-shadow: none;
    }
    
    .code-block pre {
        padding: clamp(1rem, 3vw, 1.5rem);
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
    }
    
    /* Expand/Collapse functionality for long code blocks */
    .code-expandable .code-content {
        max-height: 400px; /* Default collapsed height */
        transition: max-height 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .code-expandable .code-content.expanded {
        max-height: 2000px; /* Expanded height */
    }
    
    .code-expand-overlay {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 100px;
        background: var(--glass-expand-bg);
        display: flex;
        justify-content: center;
        align-items: flex-end;
        padding-bottom: 1rem;
        pointer-events: none;
        opacity: 1;
        transition: opacity 0.3s;
    }
    
    .code-expandable .code-content.expanded + .code-expand-overlay {
        opacity: 0;
    }
    
    .code-expand-btn {
        padding: 0.5rem 1rem;
        background: var(--glass-btn-bg);
        border: 1px solid var(--glass-btn-border);
        border-radius: 8px;
        color: var(--glass-text-secondary);
        font-size: 0.8rem;
        font-weight: 500;
        cursor: pointer;
        pointer-events: all;
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        transition: all 0.2s;
    }
    
    .code-expand-btn:hover {
        background: var(--glass-btn-hover);
    }
    
    .code-expand-btn::after {
        content: 'Show More';
    }
    
    .code-expandable .code-content.expanded + .code-expand-overlay .code-expand-btn::after {
        content: 'Show Less';
    }
    
    /* Collapsible Sections */
    .collapsible-sections {
        margin: 2rem 0;
    }
    
    .collapsible-section {
        border: 1px solid var(--border-color);
        border-radius: 8px;
        margin-bottom: 1rem;
        overflow: hidden;
    }
    
    .collapsible-section summary {
        padding: 1rem;
        font-weight: 600;
        cursor: pointer;
        background: #f8f9fa;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    .collapsible-section summary::after {
        content: '▼';
        font-size: 0.8rem;
        transition: transform 0.2s;
    }
    
    .collapsible-section[open] summary::after {
        transform: rotate(180deg);
    }
    
    .collapsible-section .section-content {
        padding: 1rem;
        background: white;
    }
    
    /* Special styling for plot sections to avoid double frames */
    .plot-section-content {
        background: transparent !important;
        padding: 0 !important;
    }
    
    .collapsible-section pre {
        background: var(--code-bg);
        padding: 1rem;
        border-radius: 6px;
        overflow-x: auto;
    }
    
    .best-code, .reference-code {
        max-height: 500px;
        overflow-y: auto;
    }
    
    /* Desktop-specific adjustments for collapsible sections */
    @media (min-width: 769px) {
        .collapsible-section {
            margin-bottom: 0.5rem;  /* Reduced from 1rem */
        }
        
        .collapsible-section summary {
            padding: 0.75rem 1rem;  /* Reduced vertical padding */
            font-size: 0.95rem;  /* Slightly smaller font */
        }
        
        .collapsible-section .section-content {
            padding: 0.75rem 1rem;  /* Reduced padding */
        }
        
        .collapsible-section pre {
            font-size: 0.85rem;  /* Smaller font for code blocks */
            line-height: 1.4;
            padding: 0.75rem;
        }
        
        /* Larger font size for reference and best code on desktop */
        .best-code {
            font-size: 1rem !important;  /* Increase from default */
            line-height: 1.5;
        }
        
        .reference-code {
            font-size: 1rem !important;  /* Increase from default */
            line-height: 1.5;
        }
        
        .collapsible-sections {
            margin: 1.5rem 0;  /* Reduced from 2rem */
        }
    }
    
    /* Floating back button - hidden by default */
    .mobile-back-button {
        display: none;
        position: fixed;
        top: 1rem;
        left: 1rem;
        z-index: 9999;  /* ensure it stays above all content */
        background: #2196F3;
        color: white;
        text-decoration: none;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
    }
    
    .mobile-back-button:hover {
        background: #1976D2;
        transform: scale(1.05);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    
    .mobile-back-button:active {
        transform: scale(0.95);
    }
    
    .mobile-back-button svg {
        width: 24px;
        height: 24px;
    }
    
    /* Responsive adjustments for mobile */
    @media (max-width: 768px) {
        /* Show floating back button on mobile */
        .mobile-back-button {
            display: flex;
        }
        
        .main-content {
            margin-left: 0;
            padding: 60px 10px 0 10px;  /* Added top padding to account for floating button */
            max-width: 100vw;
        }
        
        .container {
            padding: 0 5px;
        }
        
        .plots-container {
            flex-direction: column;
        }
        
        .plot-half {
            width: 100%;
        }
        
        /* Keep plots within container on mobile */
        .plot-container {
            overflow: hidden;
            padding: 0.5rem;
        }
        
        .plot-container img {
            max-width: 100%;
            height: auto;
        }
        
        .message {
            max-width: 100%;
        }
        
        .header-section {
            margin-bottom: 0.5rem;
            text-align: left !important;
        }
        
        /* Mobile trajectory page adjustments */
        .task-info-line, .model-info-line {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 6px;
            text-align: left !important;
            align-items: flex-start !important;
        }
        
        .task-info-line span:first-child,
        .model-info-line span:first-child {
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .task-name-display,
        .model-name-display {
            font-size: 1.1rem !important;
            font-weight: 600;
        }
        
        .info-value {
            font-size: 1.1rem !important;
            font-weight: 600;
        }
        
        .header-section {
            margin-bottom: 0.5rem !important;
        }
        
        .header-section > div:first-child {
            margin-bottom: 8px !important;
        }
    }
    
    /* Ensure container doesn't center content on desktop */
    @media (min-width: 769px) {
        .container {
            margin: 0 !important;
            text-align: left !important;
        }
        .header-section {
            text-align: left !important;
        }
        .task-info-line, .model-info-line {
            text-align: left !important;
        }
    }

    /* Additional mobile adjustments for very small screens */
    @media (max-width: 480px) {
        .header-section {
            margin-bottom: 0.25rem !important;
        }
        
        .header-section > div:first-child {
            margin-bottom: 6px !important;
        }
        
        .task-info-line, .model-info-line {
            margin-bottom: 4px !important;
        }
        
        .info-section {
            margin-bottom: 0.25rem !important;
        }
    }

    .info-section {
        flex-wrap: wrap;
        justify-content: flex-start;
        margin-bottom: 0.5rem;
    }
    
    .info-item {
        min-width: 120px;
        flex-grow: 1;
    }

    .hide-on-mobile {
        display: flex;
    }

    /* Mobile adjustments */
    @media (max-width: 768px) {
        .hide-on-mobile {
            display: none !important;
        }
        
        /* Reduce gap between collapsible sections on mobile */
        .collapsible-sections {
            margin: 1rem 0;
        }
        
        .collapsible-section {
            margin-bottom: 0.5rem;
        }
        
        .collapsible-section summary {
            padding: 0.75rem;
            font-size: 0.9rem;
        }
        
        .collapsible-section .section-content {
            padding: 0.75rem;
        }
    }
    </style>
    <script>
        function copyCode(button, codeId) {
            const code = document.getElementById(codeId).textContent;
            navigator.clipboard.writeText(code).then(() => {
                button.textContent = 'Copied!';
                button.classList.add('copied');
                setTimeout(() => {
                    button.textContent = 'Copy';
                    button.classList.remove('copied');
                }, 2000);
            });
        }

        function toggleExpand(codeBlockId) {
            const content = document.getElementById('content-' + codeBlockId);
            const overlay = document.getElementById('overlay-' + codeBlockId);
            content.classList.toggle('expanded');
            if (overlay) {
                overlay.style.display = content.classList.contains('expanded') ? 'none' : 'flex';
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            Prism.highlightAll();
        });
    </script>
</head>
<body>
    
        <div class="sidebar">
            <div class="sidebar-header">
                <a href="index.html#speedup-section" class="back-link">← Back to Speedup Table</a>
            </div>
            <div class="sidebar-content">
                <h3 style="color: black;">graph_isomorphism</h3>
                
            <div class="sidebar-task">
                <div class="task-runs">
                    
                <div class="sidebar-run">
                    <a href="graph_isomorphism_DeepSeek_R1.html">
                        <div class="run-score" style="background-color: #006400; color: #ffffff; padding: 12px 16px; font-size: 0.95rem; border-radius: 8px; font-weight: 600; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); letter-spacing: 0.025em; min-height: 24px; width: 100%; box-sizing: border-box;">DeepSeek R1 (75.81x)</div>
                    </a>
                </div>
                <div class="sidebar-run">
                    <a href="graph_isomorphism_o4-mini.html">
                        <div class="run-score" style="background-color: #006400; color: #ffffff; padding: 12px 16px; font-size: 0.95rem; border-radius: 8px; font-weight: 600; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); letter-spacing: 0.025em; min-height: 24px; width: 100%; box-sizing: border-box;">o4-mini (52.86x)</div>
                    </a>
                </div>
                <div class="sidebar-run current">
                    <a href="graph_isomorphism_Gemini_2.5_Pro.html">
                        <div class="run-score" style="background-color: #006400; color: #ffffff; padding: 12px 16px; font-size: 0.95rem; border-radius: 8px; font-weight: 600; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); letter-spacing: 0.025em; min-height: 24px; width: 100%; box-sizing: border-box;">Gemini 2.5 Pro (50.35x)</div>
                    </a>
                </div>
                <div class="sidebar-run">
                    <a href="graph_isomorphism_Claude_Opus_4.html">
                        <div class="run-score" style="background-color: #006400; color: #ffffff; padding: 12px 16px; font-size: 0.95rem; border-radius: 8px; font-weight: 600; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); letter-spacing: 0.025em; min-height: 24px; width: 100%; box-sizing: border-box;">Claude Opus 4 (27.41x)</div>
                    </a>
                </div>
                </div>
            </div>
            </div>
        </div>
    
    <!-- Floating back button for mobile -->
    <a href="index.html#speedup-section" class="mobile-back-button" aria-label="Back to Speedup Table">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M19 12H5M5 12L12 19M5 12L12 5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </a>
    
    <div class="main-content">
        <div class="container">
            <div class="header-section" style="text-align: left !important; align-items: flex-start !important; justify-content: flex-start !important;">
                <div style="margin-bottom: 20px; display: flex; align-items: center; gap: 10px; justify-content: flex-start; text-align: left;">
                    <img src="assets/AlgoTunerMascot.png" alt="AlgoTune Mascot" style="height: 32px; width: auto;">
                    <span style="font-weight: 700; font-size: 1.5rem;">AlgoTuner Trajectory</span>
                </div>
                <div class="task-info-line" style="text-align: left !important; margin-bottom: 8px; display: block;">
                    <span style="color: #6c757d; font-weight: 400;">AlgoTune Task:</span>
                    <span class="task-name-display">graph_isomorphism</span>
                </div>
                <div class="model-info-line" style="text-align: left !important; display: block;">
                    <span style="color: #6c757d; font-weight: 400;">Model:</span>
                    <span class="model-name-display" style="font-weight: 500;">Gemini 2.5 Pro</span>
                </div>
            </div>
            
            <div class="info-section">
                <div class="info-item">
                    <div class="info-label">Speedup</div>
                    <div class="info-value" style="color: #006400; font-weight: 600;">50.349x</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Total Budget</div>
                    <div class="info-value">$1.00</div>
                </div>
                <div class="info-item hide-on-mobile">
                    <div class="info-label">Commands Executed</div>
                    <div class="info-value">13</div>
                </div>
                <div class="info-item hide-on-mobile">
                    <div class="info-label">Invalid Commands</div>
                    <div class="info-value">0</div>
                </div>
                <div class="info-item hide-on-mobile">
                    <div class="info-label">Average Reference Time (ms)</div>
                    <div class="info-value">99.6 ms</div>
                </div>
            </div>
            
            
    <div class="collapsible-sections">
        <details class="collapsible-section">
            <summary>Initial System Prompt</summary>
            <div class="section-content">
                <pre>SETTING:
You&#x27;re an autonomous programmer tasked with solving a specific problem. You are to use the commands defined below to accomplish this task. Every message you send incurs a cost—you will be informed of your usage and remaining budget by the system.
You will be evaluated based on the best-performing piece of code you produce, even if the final code doesn&#x27;t work or compile (as long as it worked at some point and achieved a score, you will be eligible).
Apart from the default Python packages, you have access to the following additional packages:
 - cryptography
 - cvxpy
 - cython
 - dace
 - dask
 - diffrax
 - ecos
 - faiss-cpu
 - hdbscan
 - highspy
 - jax
 - networkx
 - numba
 - numpy
 - ortools
 - pandas
 - pot
 - psutil
 - pulp
 - pyomo
 - python-sat
 - pythran
 - scikit-learn
 - scipy
 - sympy
 - torch

YOUR TASK:
Your objective is to define a class named `Solver` in `solver.py` with a method:
```
class Solver:
    def solve(self, problem, **kwargs) -&gt; Any:
        &quot;&quot;&quot;Your implementation goes here.&quot;&quot;&quot;
        ...
```

IMPORTANT: Compilation time of your init function will not count towards your function&#x27;s runtime.

This `solve` function will be the entrypoint called by the evaluation harness. Strive to align your class and method implementation as closely as possible with the desired performance criteria.
For each instance, your function can run for at most 10x the reference runtime for that instance. Strive to have your implementation run as fast as possible, while returning the same output as the reference function (for the same given input). Be creative and optimize your approach!

Your messages should include a short thought about what you should do, followed by a _SINGLE_ command. The command must be enclosed within ``` and ```, like so:
&lt;Reasoning behind executing the command&gt;
```
&lt;command&gt;
```

IMPORTANT: Each set of triple backticks (```) must always be on their own line, without any other words or anything else on that line.

Here are the commands available to you. Ensure you include one and only one of the following commands in each of your responses:
- `edit`: Replace a range of lines with new content in a file. This is how you can create files: if the file does not exist, it will be created. Here is an example:
  ```
  edit 
  file: &lt;file_name&gt;
  lines: &lt;start_line&gt;-&lt;end_line&gt;
  ---
  &lt;new_content&gt;
  ---
  ```

  The command will:
  1. Delete the lines from &lt;start_line&gt; to &lt;end_line&gt; (inclusive)
  2. Insert &lt;new_content&gt; starting at &lt;start_line&gt;
  3. If both &lt;start_line&gt; and &lt;end_line&gt; are 0, &lt;new_content&gt; will be prepended to the file
  
  Example:
  edit
  file: solver.py
  lines: 5-7
  ---
  def improved_function():
      print(&quot;Optimized solution&quot;)
  ---
- `ls`: List all files in the current working directory.
- `view_file &lt;file_name&gt; [start_line]`: Display 100 lines of `&lt;file_name&gt;` starting from `start_line` (defaults to line 1).
- `revert`: Revert the code to the best-performing version thus far.
- `reference &lt;string&gt;`: Query the reference solver with a problem and receive its solution. If the problem&#x27;s input is a list, this command would look like: 
  ```
  reference [1,2,3,4]
  ```
- `eval_input &lt;string&gt;`: Run your current solver implementation on the given input. This is the only command that shows stdout from your solver along with both solutions. Example: 
  ```
  eval_input [1,2,3,4]
  ```
- `eval`: Run evaluation on the current solution and report the results.
- `delete`: Delete a range of lines from a file using the format:
  ```
  delete
  file: &lt;file_name&gt;
  lines: &lt;start_line&gt;-&lt;end_line&gt;

  The command will delete the lines from &lt;start_line&gt; to &lt;end_line&gt; (inclusive)
  
  Example:
  delete
  file: solver.py
  lines: 5-10
  ```
- `profile &lt;filename.py&gt; &lt;input&gt;`: Profile your currently loaded solve method&#x27;s performance on a given input. Shows the 25 most time-consuming lines. Requires specifying a python file (e.g., `solver.py`) for validation, though profiling runs on the current in-memory code.
  Example:
  ```
  profile solver.py [1, 2, 3]
  ```

- `profile_lines &lt;filename.py&gt; &lt;line_number1, line_number2, ...&gt; &lt;input&gt;`: Profiles the chosen lines of the currently loaded code on the given input. Requires specifying a python file for validation.
  Example: 
  ```
  profile_lines solver.py 1,2,3 [1, 2, 3]
  ```

**TIPS:**
After each edit, a linter will automatically run to ensure code quality. If there are critical linter errors, your changes will not be applied, and you will receive the linter&#x27;s error message. Typically, linter errors arise from issues like improper indentation—ensure your edits maintain proper code formatting.
**Cython Compilation:** Edits creating or modifying Cython (`.pyx`) files will automatically trigger a compilation attempt (requires a `setup.py`). You will be notified if compilation succeeds or fails. If it fails, the edit to the `.pyx` file will be automatically reverted.
If the code runs successfully without errors, the in-memory &#x27;last known good code&#x27; will be updated to the new version. Following successful edits, you will receive a summary of your `solve` function&#x27;s performance compared to the reference.
If you get stuck, try reverting your code and restarting your train of thought.
Do not put an if __name__ == &quot;__main__&quot;: block in your code, as it will not be ran (only the solve function will).
Keep trying to better your code until you run out of money. Do not stop beforehand!

**GOALS:**
Your primary objective is to optimize the `solve` function to run as as fast as possible, while returning the optimal solution.
You will receive better scores the quicker your solution runs, and you will be penalized for exceeding the time limit or returning non-optimal solutions.

Below you find the description of the task you will have to solve. Read it carefully and understand what the problem is and what your solver should do.

**TASK DESCRIPTION:**
Graph Isomorphism
Given two isomorphic undirected graphs G_1 and G_2, find a mapping between their nodes such that adjacency is preserved.
That is, if nodes u and v are connected in G_1, then nodes mapping [u] and mapping [v] must be connected in G_2.

Input:
A dictionary with the following keys:
  - &quot;num_nodes&quot;: Integer, number of nodes in each graph.
  - &quot;edges_g1&quot;: A list of [u, v] edges for graph 1 (undirected).
  - &quot;edges_g2&quot;: A list of [x, y] edges for graph 2 (undirected).

We guarantee that G1 and G2 are isomorphic.

Example input:
{
  &quot;num_nodes&quot;: 4,
  &quot;edges_g1&quot;: [
    [0, 1],
    [1, 2],
    [2, 3]
  ],
  &quot;edges_g2&quot;: [
    [0, 1],
    [0, 2],
    [2, 3]
  ]
}

Output:
A dictionary with a single key:
  - &quot;mapping&quot;: A list of length num_nodes, where mapping[u] = x means
               node u in G1 is mapped to node x in G2.

Example output:
{
  &quot;mapping&quot;: [2, 0, 3, 1]
}

Category: graph

Below is the reference implementation. Your function should run much quicker.

import random
from typing import Any
import networkx as nx
import numpy as np

| 01: def solve(self, problem: dict[str, Any]) -&gt; dict[str, list[int]]:
| 02:     &quot;&quot;&quot;
| 03:     Use the NetworkX VF2 isomorphism approach (GraphMatcher) to find the
| 04:     isomorphism mapping from G1 to G2. Return the mapping as a list where
| 05:     mapping[u] = v means u in G1 is mapped to v in G2.
| 06: 
| 07:     :param problem: dict with &#x27;num_nodes&#x27;, &#x27;edges_g1&#x27;, &#x27;edges_g2&#x27;
| 08:     :return: dict with &#x27;mapping&#x27;
| 09:     
| 10: 
| 11:     NOTE: Your solution must pass validation by:
| 12:     1. Returning correctly formatted output
| 13:     2. Having no NaN or infinity values
| 14:     3. Matching expected results within numerical tolerance
| 15:     &quot;&quot;&quot;
| 16:     G1 = nx.Graph()
| 17:     G2 = nx.Graph()
| 18: 
| 19:     n = problem[&quot;num_nodes&quot;]
| 20:     G1.add_nodes_from(range(n))
| 21:     G2.add_nodes_from(range(n))
| 22: 
| 23:     for u, v in problem[&quot;edges_g1&quot;]:
| 24:         G1.add_edge(u, v)
| 25:     for x, y in problem[&quot;edges_g2&quot;]:
| 26:         G2.add_edge(x, y)
| 27: 
| 28:     gm = nx.algorithms.isomorphism.GraphMatcher(G1, G2)
| 29:     if not gm.is_isomorphic():
| 30:         # By construction, it should be isomorphic, but just in case
| 31:         return {&quot;mapping&quot;: [-1] * n}
| 32: 
| 33:     # gm.isomorphisms_iter() yields all possible mappings
| 34:     # We&#x27;ll just take the first
| 35:     iso_map = next(gm.isomorphisms_iter())
| 36:     # iso_map is a dict {u_in_G1: v_in_G2}
| 37:     mapping = [iso_map[u] for u in range(n)]
| 38:     return {&quot;mapping&quot;: mapping}
| 39: 

This function will be used to check if your solution is valid for a given problem. If it returns False, it means the solution is invalid:

import random
from typing import Any
import networkx as nx
import numpy as np

| 001: def is_solution( problem: dict[str, Any], solution: dict[str, Any]) -&gt; bool:
| 002:     &quot;&quot;&quot;
| 003:     Validate if the proposed mapping in the solution correctly describes
| 004:     an isomorphism between G1 and G2.
| 005: 
| 006:     Checks:
| 007:     1. Solution format and mapping length.
| 008:     2. Whether the mapping is a valid permutation of node indices.
| 009:     3. Whether all edges in G1 map to edges in G2 under the mapping.
| 010:     4. Whether all mapped nodes preserve their degrees.
| 011: 
| 012:     :param problem: dict with &#x27;num_nodes&#x27;, &#x27;edges_g1&#x27;, &#x27;edges_g2&#x27;
| 013:     :param solution: dict with &#x27;mapping&#x27;
| 014:     :return: bool
| 015:     &quot;&quot;&quot;
| 016:     if &quot;mapping&quot; not in solution:
| 017:         logging.error(&quot;Solution must contain &#x27;mapping&#x27;.&quot;)
| 018:         return False
| 019: 
| 020:     proposed_mapping = solution[&quot;mapping&quot;]
| 021:     n = problem[&quot;num_nodes&quot;]
| 022: 
| 023:     if not isinstance(proposed_mapping, list):
| 024:         logging.error(f&quot;Mapping must be a list, got {type(proposed_mapping)}.&quot;)
| 025:         return False
| 026: 
| 027:     if len(proposed_mapping) != n:
| 028:         logging.error(f&quot;Mapping length {len(proposed_mapping)} != expected {n}.&quot;)
| 029:         return False
| 030: 
| 031:     # Check 1: Is the mapping a permutation of [0, ..., n-1]?
| 032:     # It must contain n unique elements, and these elements must be exactly 0 to n-1.
| 033:     if len(set(proposed_mapping)) != n:
| 034:         logging.error(
| 035:             f&quot;Mapping is not a permutation: contains duplicate target nodes &quot;
| 036:             f&quot;or incorrect number of unique nodes. Found {len(set(proposed_mapping))} unique values.&quot;
| 037:         )
| 038:         return False
| 039: 
| 040:     # Further check for permutation: are all values within the expected range [0, n-1]?
| 041:     # If len(set) == n and all values are ints, this check ensures they are the correct ints.
| 042:     # (e.g., avoids mappings like [0, 1, 5] for n=3 if the previous check alone was used)
| 043:     if not all(isinstance(x, int) and 0 &lt;= x &lt; n for x in proposed_mapping):
| 044:         logging.error(
| 045:             f&quot;Mapping contains invalid node indices (not integers or out of range [0, {n-1}]).&quot;
| 046:         )
| 047:         return False
| 048: 
| 049:     # Sort the set of proposed mapping values and check if it matches range(n)
| 050:     # This is a very robust way to check for permutation after confirming len and uniqueness.
| 051:     if sorted(list(set(proposed_mapping))) != list(range(n)):
| 052:         logging.error(
| 053:             f&quot;Mapping values, though unique, do not form the complete set of nodes [0, ..., {n-1}].&quot;
| 054:         )
| 055:         return False
| 056: 
| 057:     # Construct graphs G1 and G2
| 058:     G1 = nx.Graph()
| 059:     G2 = nx.Graph()
| 060:     G1.add_nodes_from(range(n))
| 061:     G2.add_nodes_from(range(n))
| 062: 
| 063:     for u, v in problem[&quot;edges_g1&quot;]:
| 064:         G1.add_edge(u, v)
| 065:     for x, y in problem[&quot;edges_g2&quot;]:
| 066:         G2.add_edge(x, y)
| 067: 
| 068:     # Check 2: Edge Preservation (G1 -&gt; G2)
| 069:     # For every edge (u,v) in G1, (mapping[u], mapping[v]) must be an edge in G2.
| 070:     for u_g1, v_g1 in G1.edges():
| 071:         try:
| 072:             u_g2 = proposed_mapping[u_g1]
| 073:             v_g2 = proposed_mapping[v_g1]
| 074:         except IndexError:
| 075:             # This should have been caught by length/value checks, but defense in depth.
| 076:             logging.error(f&quot;Node index out of bounds in mapping for G1 edge ({u_g1}, {v_g1}).&quot;)
| 077:             return False
| 078: 
| 079:         if not G2.has_edge(u_g2, v_g2):
| 080:             logging.error(
| 081:                 f&quot;Proposed mapping does not preserve edge ({u_g1},{v_g1}) from G1. &quot;
| 082:                 f&quot;Mapped to ({u_g2},{v_g2}), which is not an edge in G2.&quot;
| 083:             )
| 084:             return False
| 085: 
| 086:     # Check 3: Edge Preservation (G2 -&gt; G1 using inverse mapping)
| 087:     # For an isomorphism, the number of edges must be the same.
| 088:     # If mapping is a bijection and G1 maps to a subgraph of G2,
| 089:     # and |E1| == |E2|, then it must be an isomorphism.
| 090:     if G1.number_of_edges() != G2.number_of_edges():
| 091:         # This should ideally not happen if they are truly isomorphic
| 092:         # and the problem generation is correct.
| 093:         logging.error(
| 094:             f&quot;Number of edges mismatch: G1 has {G1.number_of_edges()}, &quot;
| 095:             f&quot;G2 has {G2.number_of_edges()}. Cannot be isomorphic.&quot;
| 096:         )
| 097:         return False
| 098: 
| 099:     # Check 4: Degree Preservation (optional but good sanity check)
| 100:     # This is implied by the bijective mapping and edge preservation if |E1| == |E2|,
| 101:     # but it&#x27;s a quick check.
| 102:     for u_g1 in range(n):
| 103:         u_g2 = proposed_mapping[u_g1]
| 104:         if G1.degree[u_g1] != G2.degree[u_g2]:
| 105:             logging.error(
| 106:                 f&quot;Degree mismatch: Node {u_g1} in G1 (degree {G1.degree[u_g1]}) &quot;
| 107:                 f&quot;maps to node {u_g2} in G2 (degree {G2.degree[u_g2]}).&quot;
| 108:             )
| 109:             return False
| 110: 
| 111:     return True
| 112:</pre>
            </div>
        </details>
        
        <details class="collapsible-section">
            <summary>AlgoTune Task Description</summary>
            <div class="section-content">
                <pre>Graph Isomorphism
Given two isomorphic undirected graphs G_1 and G_2, find a mapping between their nodes such that adjacency is preserved.
That is, if nodes u and v are connected in G_1, then nodes mapping [u] and mapping [v] must be connected in G_2.

Input:
A dictionary with the following keys:
  - &quot;num_nodes&quot;: Integer, number of nodes in each graph.
  - &quot;edges_g1&quot;: A list of [u, v] edges for graph 1 (undirected).
  - &quot;edges_g2&quot;: A list of [x, y] edges for graph 2 (undirected).

We guarantee that G1 and G2 are isomorphic.

Example input:
{
  &quot;num_nodes&quot;: 4,
  &quot;edges_g1&quot;: [
    [0, 1],
    [1, 2],
    [2, 3]
  ],
  &quot;edges_g2&quot;: [
    [0, 1],
    [0, 2],
    [2, 3]
  ]
}

Output:
A dictionary with a single key:
  - &quot;mapping&quot;: A list of length num_nodes, where mapping[u] = x means
               node u in G1 is mapped to node x in G2.

Example output:
{
  &quot;mapping&quot;: [2, 0, 3, 1]
}

Category: graph</pre>
            </div>
        </details>
        
        <details class="collapsible-section">
            <summary>Reference Implementation</summary>
            <div class="section-content">
                <pre class="reference-code"><code class="language-python">import random
from typing import Any
import networkx as nx
import numpy as np

 def solve(self, problem: dict[str, Any]) -&gt; dict[str, list[int]]:
     &quot;&quot;&quot;
     Use the NetworkX VF2 isomorphism approach (GraphMatcher) to find the
     isomorphism mapping from G1 to G2. Return the mapping as a list where
     mapping[u] = v means u in G1 is mapped to v in G2.
 
     :param problem: dict with &#x27;num_nodes&#x27;, &#x27;edges_g1&#x27;, &#x27;edges_g2&#x27;
     :return: dict with &#x27;mapping&#x27;
     
 
     NOTE: Your solution must pass validation by:
     1. Returning correctly formatted output
     2. Having no NaN or infinity values
     3. Matching expected results within numerical tolerance
     &quot;&quot;&quot;
     G1 = nx.Graph()
     G2 = nx.Graph()
 
     n = problem[&quot;num_nodes&quot;]
     G1.add_nodes_from(range(n))
     G2.add_nodes_from(range(n))
 
     for u, v in problem[&quot;edges_g1&quot;]:
         G1.add_edge(u, v)
     for x, y in problem[&quot;edges_g2&quot;]:
         G2.add_edge(x, y)
 
     gm = nx.algorithms.isomorphism.GraphMatcher(G1, G2)
     if not gm.is_isomorphic():
         # By construction, it should be isomorphic, but just in case
         return {&quot;mapping&quot;: [-1] * n}
 
     # gm.isomorphisms_iter() yields all possible mappings
     # We&#x27;ll just take the first
     iso_map = next(gm.isomorphisms_iter())
     # iso_map is a dict {u_in_G1: v_in_G2}
     mapping = [iso_map[u] for u in range(n)]
     return {&quot;mapping&quot;: mapping}</code></pre>
            </div>
        </details>
        
        <details class="collapsible-section">
            <summary>Best AlgoTuner-Generated Code</summary>
            <div class="section-content">
                <div class="best-file"><div class="file-name" style="font-weight:600; margin-bottom:0.25rem;">solver.py</div><pre class="best-code"><code class="language-python">import collections
from typing import Any, List, Dict, Tuple, Set

class Solver:
    &quot;&quot;&quot;
    Solves the graph isomorphism problem using a pruned backtracking algorithm.
    &quot;&quot;&quot;

    def solve(self, problem: Dict[str, Any], **kwargs) -&gt; Dict[str, List[int]]:
        &quot;&quot;&quot;
        Finds an isomorphism between two graphs, G1 and G2.

        The method uses a backtracking search, heavily pruned by node invariants.
        The main steps are:
        1. Represent graphs using adjacency lists for efficiency.
        2. Compute a &#x27;signature&#x27; for each node based on its degree and the
           degrees of its neighbors. This serves as a powerful invariant.
        3. Group nodes in G2 by their signature to create candidate pools for
           each node in G1.
        4. Order G1 nodes for the search, prioritizing those with the smallest
           number of candidates to fail faster and prune the search tree more
           effectively.
        5. Perform a recursive backtracking search to find a consistent mapping.
           The first valid mapping found is returned, as the problem guarantees
           an isomorphism exists.
        &quot;&quot;&quot;
        n: int = problem[&quot;num_nodes&quot;]
        edges_g1: List[List[int]] = problem[&quot;edges_g1&quot;]
        edges_g2: List[List[int]] = problem[&quot;edges_g2&quot;]

        if n == 0:
            return {&quot;mapping&quot;: []}

        adj1: List[List[int]] = [[] for _ in range(n)]
        for u, v in edges_g1:
            adj1[u].append(v)
            adj1[v].append(u)

        adj2: List[List[int]] = [[] for _ in range(n)]
        for u, v in edges_g2:
            adj2[u].append(v)
            adj2[v].append(u)
        
        adj2_sets: List[Set[int]] = [set(neighbors) for neighbors in adj2]

        deg1: List[int] = [len(adj1[i]) for i in range(n)]
        deg2: List[int] = [len(adj2[i]) for i in range(n)]

        sig1: List[Tuple[int, ...]] = [tuple(sorted(deg1[v] for v in adj1[u])) for u in range(n)]
        sig2: List[Tuple[int, ...]] = [tuple(sorted(deg2[v] for v in adj2[u])) for u in range(n)]

        candidates_map = collections.defaultdict(list)
        for i in range(n):
            # A node&#x27;s full signature includes its own degree
            full_sig = (deg2[i], sig2[i])
            candidates_map[full_sig].append(i)

        g1_nodes_ordered: List[int] = sorted(
            range(n), 
            key=lambda u: len(candidates_map.get((deg1[u], sig1[u]), []))
        )

        mapping: List[int] = [-1] * n
        reverse_mapping: Dict[int, int] = {}

        def is_consistent(u: int, v: int) -&gt; bool:
            for u_neighbor in adj1[u]:
                if mapping[u_neighbor] != -1:
                    if mapping[u_neighbor] not in adj2_sets[v]:
                        return False
            return True

        def backtrack(g1_node_idx: int) -&gt; bool:
            if g1_node_idx == n:
                return True

            u = g1_nodes_ordered[g1_node_idx]
            u_sig = (deg1[u], sig1[u])
            
            for v in candidates_map.get(u_sig, []):
                if v in reverse_mapping:
                    continue

                if is_consistent(u, v):
                    mapping[u] = v
                    reverse_mapping[v] = u
                    
                    if backtrack(g1_node_idx + 1):
                        return True
                        
                    del reverse_mapping[v]
            
            mapping[u] = -1 # Should not be strictly necessary but good practice
            return False

        backtrack(0)
        return {&quot;mapping&quot;: mapping}</code></pre></div>
            </div>
        </details>
        
        <details class="collapsible-section">
            <summary>Speedup vs Budget Plot</summary>
            <div class="section-content plot-section-content">
                
    <div class="plots-container">
        <div class="plot-section plot-half">
            <h3>Speedup vs Budget</h3>
            <div class="plot-container">
                <img src="assets/plots/graph_isomorphism_gemini-2.5-pro_20250625_150746_perf.png" alt="Speedup vs Budget Plot" />
            </div>
        </div>
        <div class="plot-section plot-half">
            <h3>Action Sequence</h3>
            <div class="plot-container">
                <img src="assets/plots/graph_isomorphism_gemini-2.5-pro_20250625_150746_actions.png" alt="Action Sequence Plot" />
            </div>
        </div>
    </div>
            </div>
        </details>
    </div>
            
            <div class="conversation-section">
                <h2>Conversation Log</h2>
                
        <div class="message assistant">
            <div class="message-header">
                Language Model <span class="command-badge edit">✏️ Code Edit</span>
            </div>
            <div class="message-content">
                The problem is to find an isomorphism between two graphs, G1 and G2. The reference solution uses `networkx`, which is known to be slower than a more specialized implementation. My goal is to create a faster solver.<br><br>My strategy will be a backtracking search algorithm, heavily pruned using graph invariants. This is a common and effective approach for graph isomorphism.<br><br>Here&#x27;s the plan:<br>1.  **Graph Representation**: I&#x27;ll use adjacency lists (list of lists) for efficient neighbor lookups, which is more memory and time-efficient for this problem than `networkx` objects. I&#x27;ll also create a set-based adjacency list for G2 for O(1) average time complexity on edge existence checks.<br>2.  **Invariant-based Pruning**: The search space of all `n!` permutations is too large. I&#x27;ll prune it by calculating invariants for each node. A node `u` in G1 can only map to a node `v` in G2 if they are indistinguishable based on these invariants.<br>    *   **Primary Invariant**: Node degree.<br>    *   **Secondary Invariant**: The sorted tuple of neighbor degrees. This &quot;signature&quot; is a much stronger invariant and will drastically reduce the number of candidate mappings for each node.<br>3.  **Backtracking Algorithm**:<br>    *   I&#x27;ll implement a recursive backtracking function.<br>    *   To guide the search, I will process nodes from G1 in a specific order: nodes with fewer potential mapping candidates in G2 will be processed first. This is a powerful heuristic that prunes the search tree early.<br>    *   At each step, the algorithm will try to map a G1 node `u` to a valid G2 candidate `v`, checking for consistency with the existing partial mapping. Consistency means that all adjacency relationships between `u` and already-mapped G1 nodes must be preserved in G2.<br>    *   Since an isomorphism is guaranteed to exist, the first complete mapping found will be the solution.<br><br>This approach avoids the overhead of `networkx` and uses a tailored, highly-pruned search, which should be significantly faster. I will start by creating the `solver.py` file with this implementation.<br><br><pre><code class="language-python">edit
file: solver.py
lines: 1-100
---
import collections
from typing import Any, List, Dict, Tuple, Set

class Solver:
    &quot;&quot;&quot;
    Solves the graph isomorphism problem using a pruned backtracking algorithm.
    &quot;&quot;&quot;

    def solve(self, problem: Dict[str, Any], **kwargs) -&gt; Dict[str, List[int]]:
        &quot;&quot;&quot;
        Finds an isomorphism between two graphs, G1 and G2.

        The method uses a backtracking search, heavily pruned by node invariants.
        The main steps are:
        1. Represent graphs using adjacency lists for efficiency.
        2. Compute a &#x27;signature&#x27; for each node based on its degree and the
           degrees of its neighbors. This serves as a powerful invariant.
        3. Group nodes in G2 by their signature to create candidate pools for
           each node in G1.
        4. Order G1 nodes for the search, prioritizing those with the smallest
           number of candidates to fail faster and prune the search tree more
           effectively.
        5. Perform a recursive backtracking search to find a consistent mapping.
           The first valid mapping found is returned, as the problem guarantees
           an isomorphism exists.
        &quot;&quot;&quot;
        n: int = problem[&quot;num_nodes&quot;]
        edges_g1: List[List[int]] = problem[&quot;edges_g1&quot;]
        edges_g2: List[List[int]] = problem[&quot;edges_g2&quot;]

        if n == 0:
            return {&quot;mapping&quot;: []}

        adj1: List[List[int]] = [[] for _ in range(n)]
        for u, v in edges_g1:
            adj1[u].append(v)
            adj1[v].append(u)

        adj2: List[List[int]] = [[] for _ in range(n)]
        for u, v in edges_g2:
            adj2[u].append(v)
            adj2[v].append(u)
        
        adj2_sets: List[Set[int]] = [set(neighbors) for neighbors in adj2]

        deg1: List[int] = [len(adj1[i]) for i in range(n)]
        deg2: List[int] = [len(adj2[i]) for i in range(n)]

        sig1: List[Tuple[int, ...]] = [tuple(sorted(deg1[v] for v in adj1[u])) for u in range(n)]
        sig2: List[Tuple[int, ...]] = [tuple(sorted(deg2[v] for v in adj2[u])) for u in range(n)]

        candidates_map = collections.defaultdict(list)
        for i in range(n):
            # A node&#x27;s full signature includes its own degree
            full_sig = (deg2[i], sig2[i])
            candidates_map[full_sig].append(i)

        g1_nodes_ordered: List[int] = sorted(
            range(n), 
            key=lambda u: len(candidates_map.get((deg1[u], sig1[u]), []))
        )

        mapping: List[int] = [-1] * n
        reverse_mapping: Dict[int, int] = {}

        def is_consistent(u: int, v: int) -&gt; bool:
            for u_neighbor in adj1[u]:
                if mapping[u_neighbor] != -1:
                    if mapping[u_neighbor] not in adj2_sets[v]:
                        return False
            return True

        def backtrack(g1_node_idx: int) -&gt; bool:
            if g1_node_idx == n:
                return True

            u = g1_nodes_ordered[g1_node_idx]
            u_sig = (deg1[u], sig1[u])
            
            for v in candidates_map.get(u_sig, []):
                if v in reverse_mapping:
                    continue

                if is_consistent(u, v):
                    mapping[u] = v
                    reverse_mapping[v] = u
                    
                    if backtrack(g1_node_idx + 1):
                        return True
                        
                    del reverse_mapping[v]
            
            mapping[u] = -1 # Should not be strictly necessary but good practice
            return False

        backtrack(0)
        return {&quot;mapping&quot;: mapping}
---</code></pre>
            </div>
        </div>
        <div class="message system">
            <div class="message-header">
                System 
            </div>
            <div class="message-content">
                You have sent 1 messages and have used up $0.0589. You have $0.9411 remaining.<br><br>Edit successful for solver.py.<br><br>Contents of solver.py (lines 1-50 out of 97)<br>(| = existing code, &gt; = modified code)<br><br><pre><code class="language-python">&gt; 01: import collections
&gt; 02: from typing import Any, List, Dict, Tuple, Set
&gt; 03: 
&gt; 04: class Solver:
&gt; 05:     &quot;&quot;&quot;
&gt; 06:     Solves the graph isomorphism problem using a pruned backtracking algorithm.
&gt; 07:     &quot;&quot;&quot;
&gt; 08: 
&gt; 09:     def solve(self, problem: Dict[str, Any], **kwargs) -&gt; Dict[str, List[int]]:
&gt; 10:         &quot;&quot;&quot;
&gt; 11:         Finds an isomorphism between two graphs, G1 and G2.
&gt; 12: 
&gt; 13:         The method uses a backtracking search, heavily pruned by node invariants.
&gt; 14:         The main steps are:
&gt; 15:         1. Represent graphs using adjacency lists for efficiency.
&gt; 16:         2. Compute a &#x27;signature&#x27; for each node based on its degree and the
&gt; 17:            degrees of its neighbors. This serves as a powerful invariant.
&gt; 18:         3. Group nodes in G2 by their signature to create candidate pools for
&gt; 19:            each node in G1.
&gt; 20:         4. Order G1 nodes for the search, prioritizing those with the smallest
&gt; 21:            number of candidates to fail faster and prune the search tree more
&gt; 22:            effectively.
&gt; 23:         5. Perform a recursive backtracking search to find a consistent mapping.
&gt; 24:            The first valid mapping found is returned, as the problem guarantees
&gt; 25:            an isomorphism exists.
&gt; 26:         &quot;&quot;&quot;
&gt; 27:         n: int = problem[&quot;num_nodes&quot;]
&gt; 28:         edges_g1: List[List[int]] = problem[&quot;edges_g1&quot;]
&gt; 29:         edges_g2: List[List[int]] = problem[&quot;edges_g2&quot;]
&gt; 30: 
&gt; 31:         if n == 0:
&gt; 32:             return {&quot;mapping&quot;: []}
&gt; 33: 
&gt; 34:         adj1: List[List[int]] = [[] for _ in range(n)]
&gt; 35:         for u, v in edges_g1:
&gt; 36:             adj1[u].append(v)
&gt; 37:             adj1[v].append(u)
&gt; 38: 
&gt; 39:         adj2: List[List[int]] = [[] for _ in range(n)]
&gt; 40:         for u, v in edges_g2:
&gt; 41:             adj2[u].append(v)
&gt; 42:             adj2[v].append(u)
&gt; 43:         
&gt; 44:         adj2_sets: List[Set[int]] = [set(neighbors) for neighbors in adj2]
&gt; 45: 
&gt; 46:         deg1: List[int] = [len(adj1[i]) for i in range(n)]
&gt; 47:         deg2: List[int] = [len(adj2[i]) for i in range(n)]
&gt; 48: 
&gt; 49:         sig1: List[Tuple[int, ...]] = [tuple(sorted(deg1[v] for v in adj1[u])) for u in range(n)]
&gt; 50:         sig2: List[Tuple[int, ...]] = [tuple(sorted(deg2[v] for v in adj2[u])) for u in range(n)]
...</code></pre><br><br>Starting evaluation...<br><br>Speedup: <span style="color:#006400; font-weight:600;">56.18</span>x<br>  (Speedup = Baseline Time / Your Time; Higher is better)<br><br>  Valid Solutions: 100%<br>  Invalid Solutions: 0%<br>  Timeouts: 0%<br><br><br>Snapshot saved Best speedup reached, state saved!<br>Among the 10+ LLMs we tested, your code did not rank in the top 3 for speed. Please use all available packages and tools to optimize its performance. Think outside the box!
            </div>
        </div>
        <div class="message assistant">
            <div class="message-header">
                Language Model <span class="command-badge edit">✏️ Code Edit</span>
            </div>
            <div class="message-content">
                An analysis of the previous solution reveals that while the backtracking algorithm with invariant-based pruning is a sound approach, its implementation in pure Python is inherently limited by interpreter overhead, especially for the recursive search component. The feedback strongly suggests leveraging specialized, high-performance libraries, which is a key strategy for tackling computationally intensive problems in a timed environment.<br><br>My new strategy is to delegate the core isomorphism search to the `igraph` library. `igraph` is a mature graph analysis package with its core algorithms implemented in C, offering a significant performance advantage over native Python code.<br><br>Here&#x27;s the plan:<br>1.  **Utilize `igraph`**: I will use the `igraph` library to represent the graphs and solve the isomorphism problem. This directly addresses the performance bottleneck of the previous Python-based search.<br>2.  **Graph Creation**: The input edge lists will be used to construct `igraph.Graph` objects for G1 and G2.<br>3.  **VF2 Algorithm**: I will call the `get_isomorphism_vf2()` method. This method implements the VF2 algorithm, a fast backtracking algorithm for graph isomorphism, in compiled C code. Since the problem guarantees an isomorphism exists, this function will efficiently find one.<br>4.  **Mapping Inversion**: The `igraph` method returns a mapping from G2&#x27;s nodes to G1&#x27;s nodes. The required output format is a mapping from G1 to G2. Therefore, I will perform a simple inversion of the result from `igraph` to produce the final correct mapping.<br><br>This approach replaces the custom, recursive Python solver with a single call to a highly optimized, compiled library function, which is expected to yield a substantial speedup.<br><br><pre><code class="language-python">edit
file: solver.py
lines: 1-100
---
import igraph as ig
from typing import Any, List, Dict

class Solver:
    &quot;&quot;&quot;
    Solves the graph isomorphism problem using the igraph library.
    &quot;&quot;&quot;

    def solve(self, problem: Dict[str, Any], **kwargs) -&gt; Dict[str, List[int]]:
        &quot;&quot;&quot;
        Finds an isomorphism between two graphs, G1 and G2, using the
        highly optimized VF2 algorithm implementation from the igraph library.

        The problem of finding an isomorphism is computationally hard (GI-complete),
        and a custom backtracking search in Python is often too slow. The `igraph`
        library provides a C-backed, highly optimized implementation of the VF2
        algorithm, which is a standard for this problem. This approach delegates
        the core combinatorial search to a much faster, compiled library.

        The steps are:
        1. Extract the number of nodes and edge lists for both graphs from the
           problem dictionary.
        2. Create `igraph.Graph` objects from these definitions. The graphs are
           treated as undirected.
        3. Call the `get_isomorphism_vf2()` method. This method finds a mapping
           from the vertices of the second graph (G2) to the first (G1).
        4. Invert the resulting mapping to match the required output format,
           where `mapping[i]` is the node in G2 that node `i` from G1 maps to.
        &quot;&quot;&quot;
        n: int = problem[&quot;num_nodes&quot;]
        edges_g1: List[List[int]] = problem[&quot;edges_g1&quot;]
        edges_g2: List[List[int]] = problem[&quot;edges_g2&quot;]

        if n == 0:
            return {&quot;mapping&quot;: []}

        # Create igraph Graph objects. igraph is highly optimized with a C core,
        # making it significantly faster than pure Python implementations for
        # graph algorithms.
        g1 = ig.Graph(n=n, edges=edges_g1, directed=False)
        g2 = ig.Graph(n=n, edges=edges_g2, directed=False)

        # get_isomorphism_vf2 finds an isomorphism between two graphs.
        # The problem guarantees that one exists.
        # The method returns a list where the i-th element is the vertex
        # in g1 that corresponds to vertex i in g2.
        # Let&#x27;s call this igraph_map: igraph_map[g2_node] = g1_node
        igraph_map = g1.get_isomorphism_vf2(g2)

        # We need to return a mapping where mapping[g1_node] = g2_node.
        # So we need to invert the igraph_map.
        mapping = [-1] * n
        for g2_node, g1_node in enumerate(igraph_map):
            mapping[g1_node] = g2_node

        return {&quot;mapping&quot;: mapping}
---</code></pre>
            </div>
        </div>
        <div class="message system">
            <div class="message-header">
                System 
            </div>
            <div class="message-content">
                You have sent 2 messages and have used up $0.1127. You have $0.8873 remaining.<br><br>Edit successful for solver.py.<br><br>Contents of solver.py (lines 1-50 out of 56)<br>(| = existing code, &gt; = modified code)<br><br><pre><code class="language-python">&gt; 01: import igraph as ig
&gt; 02: from typing import Any, List, Dict
&gt; 03: 
&gt; 04: class Solver:
&gt; 05:     &quot;&quot;&quot;
&gt; 06:     Solves the graph isomorphism problem using the igraph library.
&gt; 07:     &quot;&quot;&quot;
&gt; 08: 
&gt; 09:     def solve(self, problem: Dict[str, Any], **kwargs) -&gt; Dict[str, List[int]]:
&gt; 10:         &quot;&quot;&quot;
&gt; 11:         Finds an isomorphism between two graphs, G1 and G2, using the
&gt; 12:         highly optimized VF2 algorithm implementation from the igraph library.
&gt; 13: 
&gt; 14:         The problem of finding an isomorphism is computationally hard (GI-complete),
&gt; 15:         and a custom backtracking search in Python is often too slow. The `igraph`
&gt; 16:         library provides a C-backed, highly optimized implementation of the VF2
&gt; 17:         algorithm, which is a standard for this problem. This approach delegates
&gt; 18:         the core combinatorial search to a much faster, compiled library.
&gt; 19: 
&gt; 20:         The steps are:
&gt; 21:         1. Extract the number of nodes and edge lists for both graphs from the
&gt; 22:            problem dictionary.
&gt; 23:         2. Create `igraph.Graph` objects from these definitions. The graphs are
&gt; 24:            treated as undirected.
&gt; 25:         3. Call the `get_isomorphism_vf2()` method. This method finds a mapping
&gt; 26:            from the vertices of the second graph (G2) to the first (G1).
&gt; 27:         4. Invert the resulting mapping to match the required output format,
&gt; 28:            where `mapping[i]` is the node in G2 that node `i` from G1 maps to.
&gt; 29:         &quot;&quot;&quot;
&gt; 30:         n: int = problem[&quot;num_nodes&quot;]
&gt; 31:         edges_g1: List[List[int]] = problem[&quot;edges_g1&quot;]
&gt; 32:         edges_g2: List[List[int]] = problem[&quot;edges_g2&quot;]
&gt; 33: 
&gt; 34:         if n == 0:
&gt; 35:             return {&quot;mapping&quot;: []}
&gt; 36: 
&gt; 37:         # Create igraph Graph objects. igraph is highly optimized with a C core,
&gt; 38:         # making it significantly faster than pure Python implementations for
&gt; 39:         # graph algorithms.
&gt; 40:         g1 = ig.Graph(n=n, edges=edges_g1, directed=False)
&gt; 41:         g2 = ig.Graph(n=n, edges=edges_g2, directed=False)
&gt; 42: 
&gt; 43:         # get_isomorphism_vf2 finds an isomorphism between two graphs.
&gt; 44:         # The problem guarantees that one exists.
&gt; 45:         # The method returns a list where the i-th element is the vertex
&gt; 46:         # in g1 that corresponds to vertex i in g2.
&gt; 47:         # Let&#x27;s call this igraph_map: igraph_map[g2_node] = g1_node
&gt; 48:         igraph_map = g1.get_isomorphism_vf2(g2)
&gt; 49: 
&gt; 50:         # We need to return a mapping where mapping[g1_node] = g2_node.
...</code></pre><br><br>Solver validation failed: Failed to import solver.py: No module named &#x27;igraph&#x27;
            </div>
        </div>
        <div class="message assistant">
            <div class="message-header">
                Language Model <span class="command-badge edit">✏️ Code Edit</span>
            </div>
            <div class="message-content">
                An analysis of the previous attempt shows that while using a high-performance library like `igraph` is an excellent strategy, its availability cannot be guaranteed in all execution environments. The failure was due to an `ImportError`, indicating the need for a solution that relies only on standard or provided libraries.<br><br>My first successful attempt used a pure Python backtracking algorithm pruned by simple node invariants (degree and neighbor degrees). It achieved a significant speedup but was not top-tier, suggesting that more powerful pruning is necessary.<br><br>My new strategy is to enhance the pure Python backtracking solver with a much more sophisticated pruning technique: the **Weisfeiler-Leman (WL) algorithm**, also known as color refinement.<br><br>Here&#x27;s the refined plan:<br>1.  **Weisfeiler-Leman Preprocessing**: Before starting the search, I will run a few iterations of the WL algorithm on both graphs.<br>    *   **Initialization**: Each node&#x27;s initial &quot;color&quot; will be its degree.<br>    *   **Iterative Refinement**: In each iteration, a new color for a node is computed by creating a signature from its current color and the multiset of its neighbors&#x27; colors. This signature is then hashed to form the new color.<br>    *   This process generates a highly descriptive &quot;final color&quot; for each node, which serves as a powerful invariant. Nodes that are structurally different will almost always end up with different final colors.<br><br>2.  **Stronger Candidate Pruning**: The candidate pool for a node `u` in G1 will now consist only of nodes `v` in G2 that have the *exact same final WL color*. This is a much stronger filter than the simple degree-based invariant and will drastically reduce the branching factor of the search tree.<br><br>3.  **Optimized Backtracking**:<br>    *   The core backtracking logic remains, but it will operate on this heavily pruned search space.<br>    *   The heuristic of processing G1 nodes with the smallest number of candidates first is retained, as it&#x27;s crucial for failing fast.<br>    *   Minor implementation details, like using a boolean list instead of a dictionary to track used nodes in G2, will be employed for marginal performance gains.<br><br>This approach combines a standard backtracking framework with a state-of-the-art (for classical algorithms) polynomial-time heuristic. The WL preprocessing step effectively partitions the nodes into equivalence classes, allowing the subsequent exponential search to solve a much smaller problem.<br><br><pre><code class="language-python">edit
file: solver.py
lines: 1-100
---
import collections
from typing import Any, List, Dict, Tuple, Set

class Solver:
    &quot;&quot;&quot;
    Solves the graph isomorphism problem using a backtracking algorithm pruned
    by Weisfeiler-Leman color refinement.
    &quot;&quot;&quot;

    def solve(self, problem: Dict[str, Any], **kwargs) -&gt; Dict[str, List[int]]:
        &quot;&quot;&quot;
        Finds an isomorphism between G1 and G2.

        This solution uses a two-stage approach:
        1.  **Weisfeiler-Leman (WL) Color Refinement**: A powerful polynomial-time
            heuristic to partition nodes into equivalence classes based on
            structural information. Each node is assigned a &quot;color&quot;, which is
            iteratively refined based on the colors of its neighbors. This
            creates a strong node invariant that significantly prunes the search space.
            Nodes in G1 can only map to nodes in G2 with the same final WL color.

        2.  **Pruned Backtracking Search**: A standard backtracking algorithm explores
            the possible mappings. The search is heavily guided by the WL partitions.
            It prioritizes mapping nodes with the fewest possible candidates first,
            a heuristic that leads to faster pruning of the search tree.

        This combination avoids the overhead and dependency issues of external
        libraries while being significantly faster than a naive search.
        &quot;&quot;&quot;
        n: int = problem[&quot;num_nodes&quot;]
        edges_g1: List[List[int]] = problem[&quot;edges_g1&quot;]
        edges_g2: List[List[int]] = problem[&quot;edges_g2&quot;]

        if n == 0:
            return {&quot;mapping&quot;: []}

        adj1: List[List[int]] = [[] for _ in range(n)]
        for u, v in edges_g1:
            adj1[u].append(v)
            adj1[v].append(u)

        adj2: List[List[int]] = [[] for _ in range(n)]
        for u, v in edges_g2:
            adj2[u].append(v)
            adj2[v].append(u)
        
        adj2_sets: List[Set[int]] = [set(neighbors) for neighbors in adj2]

        # --- Weisfeiler-Leman Color Refinement ---
        colors1 = [len(adj) for adj in adj1]
        colors2 = [len(adj) for adj in adj2]

        for _ in range(10): # A small number of iterations is usually sufficient
            # For G1
            new_colors1 = [hash((colors1[i], tuple(sorted(colors1[j] for j in adj1[i])))) for i in range(n)]
            # For G2
            new_colors2 = [hash((colors2[i], tuple(sorted(colors2[j] for j in adj2[i])))) for i in range(n)]
            
            colors1 = new_colors1
            colors2 = new_colors2

        # --- Candidate Generation based on WL colors ---
        candidates_map = collections.defaultdict(list)
        for i in range(n):
            candidates_map[colors2[i]].append(i)

        # --- Backtracking Search ---
        g1_nodes_ordered: List[int] = sorted(
            range(n), 
            key=lambda u: len(candidates_map.get(colors1[u], []))
        )

        mapping: List[int] = [-1] * n
        g2_nodes_used: List[bool] = [False] * n

        def is_consistent(u: int, v: int) -&gt; bool:
            for u_neighbor in adj1[u]:
                mapped_neighbor = mapping[u_neighbor]
                if mapped_neighbor != -1 and mapped_neighbor not in adj2_sets[v]:
                    return False
            return True

        def backtrack(g1_node_idx: int) -&gt; bool:
            if g1_node_idx == n:
                return True

            u = g1_nodes_ordered[g1_node_idx]
            u_color = colors1[u]
            
            for v in candidates_map.get(u_color, []):
                if not g2_nodes_used[v] and is_consistent(u, v):
                    mapping[u] = v
                    g2_nodes_used[v] = True
                    
                    if backtrack(g1_node_idx + 1):
                        return True
                        
                    g2_nodes_used[v] = False
            
            mapping[u] = -1
            return False

        backtrack(0)
        return {&quot;mapping&quot;: mapping}
---</code></pre>
            </div>
        </div>
        <div class="message system">
            <div class="message-header">
                System 
            </div>
            <div class="message-content">
                You have sent 3 messages and have used up $0.1605. You have $0.8395 remaining.<br><br>Edit successful for solver.py.<br><br>Contents of solver.py (lines 1-50 out of 104)<br>(| = existing code, &gt; = modified code)<br><br><pre><code class="language-python">&gt; 001: import collections
&gt; 002: from typing import Any, List, Dict, Tuple, Set
&gt; 003: 
&gt; 004: class Solver:
&gt; 005:     &quot;&quot;&quot;
&gt; 006:     Solves the graph isomorphism problem using a backtracking algorithm pruned
&gt; 007:     by Weisfeiler-Leman color refinement.
&gt; 008:     &quot;&quot;&quot;
&gt; 009: 
&gt; 010:     def solve(self, problem: Dict[str, Any], **kwargs) -&gt; Dict[str, List[int]]:
&gt; 011:         &quot;&quot;&quot;
&gt; 012:         Finds an isomorphism between G1 and G2.
&gt; 013: 
&gt; 014:         This solution uses a two-stage approach:
&gt; 015:         1.  **Weisfeiler-Leman (WL) Color Refinement**: A powerful polynomial-time
&gt; 016:             heuristic to partition nodes into equivalence classes based on
&gt; 017:             structural information. Each node is assigned a &quot;color&quot;, which is
&gt; 018:             iteratively refined based on the colors of its neighbors. This
&gt; 019:             creates a strong node invariant that significantly prunes the search space.
&gt; 020:             Nodes in G1 can only map to nodes in G2 with the same final WL color.
&gt; 021: 
&gt; 022:         2.  **Pruned Backtracking Search**: A standard backtracking algorithm explores
&gt; 023:             the possible mappings. The search is heavily guided by the WL partitions.
&gt; 024:             It prioritizes mapping nodes with the fewest possible candidates first,
&gt; 025:             a heuristic that leads to faster pruning of the search tree.
&gt; 026: 
&gt; 027:         This combination avoids the overhead and dependency issues of external
&gt; 028:         libraries while being significantly faster than a naive search.
&gt; 029:         &quot;&quot;&quot;
&gt; 030:         n: int = problem[&quot;num_nodes&quot;]
&gt; 031:         edges_g1: List[List[int]] = problem[&quot;edges_g1&quot;]
&gt; 032:         edges_g2: List[List[int]] = problem[&quot;edges_g2&quot;]
&gt; 033: 
&gt; 034:         if n == 0:
&gt; 035:             return {&quot;mapping&quot;: []}
&gt; 036: 
&gt; 037:         adj1: List[List[int]] = [[] for _ in range(n)]
&gt; 038:         for u, v in edges_g1:
&gt; 039:             adj1[u].append(v)
&gt; 040:             adj1[v].append(u)
&gt; 041: 
&gt; 042:         adj2: List[List[int]] = [[] for _ in range(n)]
&gt; 043:         for u, v in edges_g2:
&gt; 044:             adj2[u].append(v)
&gt; 045:             adj2[v].append(u)
&gt; 046:         
&gt; 047:         adj2_sets: List[Set[int]] = [set(neighbors) for neighbors in adj2]
&gt; 048: 
&gt; 049:         # --- Weisfeiler-Leman Color Refinement ---
&gt; 050:         colors1 = [len(adj) for adj in adj1]
...</code></pre><br><br>Starting evaluation...<br><br>Speedup: <span style="color:#006400; font-weight:600;">9.55</span>x<br>  (Speedup = Baseline Time / Your Time; Higher is better)<br><br>  Valid Solutions: 100%<br>  Invalid Solutions: 0%<br>  Timeouts: 0%<br><br><br>Speedup did not improve, snapshot not saved.
            </div>
        </div>
        <div class="message assistant">
            <div class="message-header">
                Language Model <span class="command-badge edit">✏️ Code Edit</span>
            </div>
            <div class="message-content">
                An analysis of my previous attempts reveals a crucial insight: the pure Python backtracking solver using a simple, first-order neighborhood invariant (`(degree, sorted_neighbor_degrees)`) achieved a very high speedup (56x). My subsequent attempt to use a more complex invariant (Weisfeiler-Leman) was significantly slower (9.55x). This indicates that for the given problem set, the computational overhead of the WL iterations outweighed its additional pruning benefits. The `igraph` attempt failed due to library restrictions.<br><br>Therefore, the most effective strategy is to return to the successful backtracking approach and refine its implementation for maximum performance within the pure Python environment.<br><br>My refined strategy is as follows:<br>1.  **Revert to the Core Successful Algorithm**: The foundation will be the backtracking search pruned by the `(degree, sorted_neighbor_degrees)` invariant. This invariant proved to be the sweet spot between computational cost and pruning power.<br>2.  **Optimize Data Structures**:<br>    *   I will continue to use adjacency lists for graph representation and a list of sets for G2&#x27;s adjacencies to ensure fast `O(1)` average time edge checks.<br>    *   For tracking which nodes in G2 have been used in the current mapping, I will use a boolean list (`g2_nodes_used`) instead of a dictionary (`reverse_mapping`). List indexing is faster than dictionary key lookups, providing a small but valuable micro-optimization.<br>3.  **Ensure Correctness and Clarity**: The backtracking logic will be carefully implemented to ensure state is correctly managed. Specifically, when a recursive path fails, both the mapping for the current G1 node and its corresponding G2 node&#x27;s &quot;used&quot; status must be reset. This prevents state pollution for subsequent branches of the search tree.<br>4.  **Retain Key Heuristics**: The &quot;minimum remaining values&quot; heuristic—processing G1 nodes with the smallest number of potential candidates first—is critical for performance and will be retained.<br><br>This approach refines the already proven-effective solution, focusing on small but impactful implementation details to squeeze out additional performance without introducing the high overhead that made the WL approach slower.<br><br><pre><code class="language-python">edit
file: solver.py
lines: 1-100
---
import collections
from typing import Any, List, Dict, Tuple, Set

class Solver:
    &quot;&quot;&quot;
    Solves the graph isomorphism problem using a highly-optimized backtracking algorithm.
    &quot;&quot;&quot;

    def solve(self, problem: Dict[str, Any], **kwargs) -&gt; Dict[str, List[int]]:
        &quot;&quot;&quot;
        Finds an isomorphism between two graphs, G1 and G2.

        This solution is a refined version of a classic backtracking algorithm,
        optimized with several key techniques:

        1.  **Strong Invariant-based Pruning**: Before searching, a powerful and
            computationally cheap invariant is calculated for each node: a tuple
            containing the node&#x27;s own degree and a sorted tuple of its neighbors&#x27;
            degrees. This allows for a drastic reduction of the search space by
            ensuring a node `u` in G1 is only ever considered for mapping to a
            node `v` in G2 if they share this identical structural signature.

        2.  **Heuristic Search Order**: The backtracking algorithm processes nodes
            from G1 in a specific order, prioritizing nodes that have the smallest
            number of potential candidate mappings in G2. This &quot;fail-fast&quot;
            strategy prunes large branches of the search tree early on.

        3.  **Efficient Data Structures**: The implementation uses adjacency lists,
            sets for O(1) edge lookups in G2, and a boolean list for tracking
            used nodes, all contributing to lower overhead during the intensive
            search phase.
        &quot;&quot;&quot;
        n: int = problem[&quot;num_nodes&quot;]
        edges_g1: List[List[int]] = problem[&quot;edges_g1&quot;]
        edges_g2: List[List[int]] = problem[&quot;edges_g2&quot;]

        if n == 0:
            return {&quot;mapping&quot;: []}

        adj1: List[List[int]] = [[] for _ in range(n)]
        for u, v in edges_g1:
            adj1[u].append(v)
            adj1[v].append(u)

        adj2: List[List[int]] = [[] for _ in range(n)]
        for u, v in edges_g2:
            adj2[u].append(v)
            adj2[v].append(u)
        
        adj2_sets: List[Set[int]] = [set(neighbors) for neighbors in adj2]

        deg1: List[int] = [len(adj1[i]) for i in range(n)]
        deg2: List[int] = [len(adj2[i]) for i in range(n)]

        sig1: List[Tuple[int, ...]] = [tuple(sorted(deg1[v] for v in adj1[u])) for u in range(n)]
        sig2: List[Tuple[int, ...]] = [tuple(sorted(deg2[v] for v in adj2[u])) for u in range(n)]

        candidates_map = collections.defaultdict(list)
        for i in range(n):
            full_sig = (deg2[i], sig2[i])
            candidates_map[full_sig].append(i)

        g1_nodes_ordered: List[int] = sorted(
            range(n), 
            key=lambda u: len(candidates_map.get((deg1[u], sig1[u]), []))
        )

        mapping: List[int] = [-1] * n
        g2_nodes_used: List[bool] = [False] * n

        def is_consistent(u: int, v: int) -&gt; bool:
            for u_neighbor in adj1[u]:
                mapped_neighbor = mapping[u_neighbor]
                if mapped_neighbor != -1 and mapped_neighbor not in adj2_sets[v]:
                    return False
            return True

        def backtrack(g1_node_idx: int) -&gt; bool:
            if g1_node_idx == n:
                return True

            u = g1_nodes_ordered[g1_node_idx]
            u_sig = (deg1[u], sig1[u])
            
            for v in candidates_map.get(u_sig, []):
                if not g2_nodes_used[v] and is_consistent(u, v):
                    mapping[u] = v
                    g2_nodes_used[v] = True
                    
                    if backtrack(g1_node_idx + 1):
                        return True
                        
                    g2_nodes_used[v] = False
            
            mapping[u] = -1
            return False

        backtrack(0)
        return {&quot;mapping&quot;: mapping}
---</code></pre>
            </div>
        </div>
        <div class="message system">
            <div class="message-header">
                System 
            </div>
            <div class="message-content">
                You have sent 4 messages and have used up $0.2422. You have $0.7578 remaining.<br><br>Edit failed (and thus not applied) for solver.py: Syntax error: unexpected indent (line 100)<br><br>Proposed changes - This is what you tried to apply (lines 54-103 out of 103):<br>(| = existing code, &gt; = modified code)<br><br><pre><code class="language-python">...
&gt; 054: 
&gt; 055:         sig1: List[Tuple[int, ...]] = [tuple(sorted(deg1[v] for v in adj1[u])) for u in range(n)]
&gt; 056:         sig2: List[Tuple[int, ...]] = [tuple(sorted(deg2[v] for v in adj2[u])) for u in range(n)]
&gt; 057: 
&gt; 058:         candidates_map = collections.defaultdict(list)
&gt; 059:         for i in range(n):
&gt; 060:             full_sig = (deg2[i], sig2[i])
&gt; 061:             candidates_map[full_sig].append(i)
&gt; 062: 
&gt; 063:         g1_nodes_ordered: List[int] = sorted(
&gt; 064:             range(n), 
&gt; 065:             key=lambda u: len(candidates_map.get((deg1[u], sig1[u]), []))
&gt; 066:         )
&gt; 067: 
&gt; 068:         mapping: List[int] = [-1] * n
&gt; 069:         g2_nodes_used: List[bool] = [False] * n
&gt; 070: 
&gt; 071:         def is_consistent(u: int, v: int) -&gt; bool:
&gt; 072:             for u_neighbor in adj1[u]:
&gt; 073:                 mapped_neighbor = mapping[u_neighbor]
&gt; 074:                 if mapped_neighbor != -1 and mapped_neighbor not in adj2_sets[v]:
&gt; 075:                     return False
&gt; 076:             return True
&gt; 077: 
&gt; 078:         def backtrack(g1_node_idx: int) -&gt; bool:
&gt; 079:             if g1_node_idx == n:
&gt; 080:                 return True
&gt; 081: 
&gt; 082:             u = g1_nodes_ordered[g1_node_idx]
&gt; 083:             u_sig = (deg1[u], sig1[u])
&gt; 084:             
&gt; 085:             for v in candidates_map.get(u_sig, []):
&gt; 086:                 if not g2_nodes_used[v] and is_consistent(u, v):
&gt; 087:                     mapping[u] = v
&gt; 088:                     g2_nodes_used[v] = True
&gt; 089:                     
&gt; 090:                     if backtrack(g1_node_idx + 1):
&gt; 091:                         return True
&gt; 092:                         
&gt; 093:                     g2_nodes_used[v] = False
&gt; 094:             
&gt; 095:             mapping[u] = -1
&gt; 096:             return False
&gt; 097: 
&gt; 098:         backtrack(0)
&gt; 099:         return {&quot;mapping&quot;: mapping}
| 100:             return False
| 101: 
| 102:         backtrack(0)
| 103:         return {&quot;mapping&quot;: mapping}</code></pre><br><br>CURRENT FILE - This is what&#x27;s actually in the file (lines 1-50 out of 104):<br>(| = existing code, &gt; = modified code)<br><br><pre><code class="language-python">| 001: import collections
| 002: from typing import Any, List, Dict, Tuple, Set
| 003: 
| 004: class Solver:
| 005:     &quot;&quot;&quot;
| 006:     Solves the graph isomorphism problem using a backtracking algorithm pruned
| 007:     by Weisfeiler-Leman color refinement.
| 008:     &quot;&quot;&quot;
| 009: 
| 010:     def solve(self, problem: Dict[str, Any], **kwargs) -&gt; Dict[str, List[int]]:
| 011:         &quot;&quot;&quot;
| 012:         Finds an isomorphism between G1 and G2.
| 013: 
| 014:         This solution uses a two-stage approach:
| 015:         1.  **Weisfeiler-Leman (WL) Color Refinement**: A powerful polynomial-time
| 016:             heuristic to partition nodes into equivalence classes based on
| 017:             structural information. Each node is assigned a &quot;color&quot;, which is
| 018:             iteratively refined based on the colors of its neighbors. This
| 019:             creates a strong node invariant that significantly prunes the search space.
| 020:             Nodes in G1 can only map to nodes in G2 with the same final WL color.
| 021: 
| 022:         2.  **Pruned Backtracking Search**: A standard backtracking algorithm explores
| 023:             the possible mappings. The search is heavily guided by the WL partitions.
| 024:             It prioritizes mapping nodes with the fewest possible candidates first,
| 025:             a heuristic that leads to faster pruning of the search tree.
| 026: 
| 027:         This combination avoids the overhead and dependency issues of external
| 028:         libraries while being significantly faster than a naive search.
| 029:         &quot;&quot;&quot;
| 030:         n: int = problem[&quot;num_nodes&quot;]
| 031:         edges_g1: List[List[int]] = problem[&quot;edges_g1&quot;]
| 032:         edges_g2: List[List[int]] = problem[&quot;edges_g2&quot;]
| 033: 
| 034:         if n == 0:
| 035:             return {&quot;mapping&quot;: []}
| 036: 
| 037:         adj1: List[List[int]] = [[] for _ in range(n)]
| 038:         for u, v in edges_g1:
| 039:             adj1[u].append(v)
| 040:             adj1[v].append(u)
| 041: 
| 042:         adj2: List[List[int]] = [[] for _ in range(n)]
| 043:         for u, v in edges_g2:
| 044:             adj2[u].append(v)
| 045:             adj2[v].append(u)
| 046:         
| 047:         adj2_sets: List[Set[int]] = [set(neighbors) for neighbors in adj2]
| 048: 
| 049:         # --- Weisfeiler-Leman Color Refinement ---
| 050:         colors1 = [len(adj) for adj in adj1]
...</code></pre>
            </div>
        </div>
        <div class="message assistant">
            <div class="message-header">
                Language Model <span class="command-badge edit">✏️ Code Edit</span>
            </div>
            <div class="message-content">
                The previous attempt failed due to a syntax error from an incorrect partial edit. The server&#x27;s file still contains the slower Weisfeiler-Leman implementation. My goal is to replace the entire file with the faster, simpler, and previously successful backtracking algorithm.<br><br>The strategy is to revert to the code that achieved the 56x speedup, ensuring it is submitted as a complete, clean file to avoid any editing artifacts.<br><br>**The Core Strategy:**<br><br>1.  **Invariant Calculation**: Use the computationally inexpensive yet powerful `(degree, sorted_neighbor_degrees)` tuple as the node invariant. This proved to be the most effective balance between pruning power and overhead for this problem set.<br>2.  **Candidate Pruning**: Create candidate pools by grouping nodes in G2 that share the same invariant signature. This drastically reduces the search space.<br>3.  **Heuristic Search Order**: Process G1 nodes with the smallest candidate pools first. This &quot;fail-fast&quot; heuristic is crucial for performance, as it prunes the search tree at its highest levels.<br>4.  **Optimized Backtracking**: Implement the recursive search using efficient data structures:<br>    *   Adjacency lists for graph representation.<br>    *   A list of sets for G2&#x27;s adjacencies for fast `O(1)` average time edge checks.<br>    *   A boolean list (`g2_nodes_used`) to track used nodes, which is faster than dictionary lookups.<br><br>This is a resubmission of a proven, high-performance algorithm, now formatted as a complete file replacement to guarantee a correct and successful edit.<br><br><pre><code class="language-python">edit
file: solver.py
lines: 1-120
---
import collections
from typing import Any, List, Dict, Tuple, Set

class Solver:
    &quot;&quot;&quot;
    Solves the graph isomorphism problem using a highly-optimized backtracking algorithm.
    &quot;&quot;&quot;

    def solve(self, problem: Dict[str, Any], **kwargs) -&gt; Dict[str, List[int]]:
        &quot;&quot;&quot;
        Finds an isomorphism between two graphs, G1 and G2.

        This solution is a refined version of a classic backtracking algorithm,
        optimized with several key techniques:

        1.  **Strong Invariant-based Pruning**: Before searching, a powerful and
            computationally cheap invariant is calculated for each node: a tuple
            containing the node&#x27;s own degree and a sorted tuple of its neighbors&#x27;
            degrees. This allows for a drastic reduction of the search space by
            ensuring a node `u` in G1 is only ever considered for mapping to a
            node `v` in G2 if they share this identical structural signature.

        2.  **Heuristic Search Order**: The backtracking algorithm processes nodes
            from G1 in a specific order, prioritizing nodes that have the smallest
            number of potential candidate mappings in G2. This &quot;fail-fast&quot;
            strategy prunes large branches of the search tree early on.

        3.  **Efficient Data Structures**: The implementation uses adjacency lists,
            sets for O(1) edge lookups in G2, and a boolean list for tracking
            used nodes, all contributing to lower overhead during the intensive
            search phase.
        &quot;&quot;&quot;
        n: int = problem[&quot;num_nodes&quot;]
        edges_g1: List[List[int]] = problem[&quot;edges_g1&quot;]
        edges_g2: List[List[int]] = problem[&quot;edges_g2&quot;]

        if n == 0:
            return {&quot;mapping&quot;: []}

        adj1: List[List[int]] = [[] for _ in range(n)]
        for u, v in edges_g1:
            adj1[u].append(v)
            adj1[v].append(u)

        adj2: List[List[int]] = [[] for _ in range(n)]
        for u, v in edges_g2:
            adj2[u].append(v)
            adj2[v].append(u)
        
        adj2_sets: List[Set[int]] = [set(neighbors) for neighbors in adj2]

        # --- Invariant Calculation ---
        deg1: List[int] = [len(adj1[i]) for i in range(n)]
        deg2: List[int] = [len(adj2[i]) for i in range(n)]

        # The signature is a tuple of the degrees of a node&#x27;s neighbors.
        sig1: List[Tuple[int, ...]] = [tuple(sorted(deg1[v] for v in adj1[u])) for u in range(n)]
        sig2: List[Tuple[int, ...]] = [tuple(sorted(deg2[v] for v in adj2[u])) for u in range(n)]

        # --- Candidate Generation ---
        # Group G2 nodes by their full signature (degree, neighbor_degrees_tuple)
        candidates_map = collections.defaultdict(list)
        for i in range(n):
            full_sig = (deg2[i], sig2[i])
            candidates_map[full_sig].append(i)

        # --- Heuristic Search Ordering ---
        # Order G1 nodes by the size of their candidate pool (smallest first)
        g1_nodes_ordered: List[int] = sorted(
            range(n), 
            key=lambda u: len(candidates_map.get((deg1[u], sig1[u]), []))
        )

        # --- Backtracking Search ---
        mapping: List[int] = [-1] * n
        g2_nodes_used: List[bool] = [False] * n

        def is_consistent(u: int, v: int) -&gt; bool:
            # Check if the proposed mapping (u -&gt; v) is consistent with existing mappings.
            # An edge (u, u_neighbor) in G1 must correspond to an edge (v, mapped_neighbor) in G2.
            for u_neighbor in adj1[u]:
                mapped_neighbor = mapping[u_neighbor]
                if mapped_neighbor != -1 and mapped_neighbor not in adj2_sets[v]:
                    return False
            return True

        def backtrack(g1_node_idx: int) -&gt; bool:
            if g1_node_idx == n:
                # All nodes have been mapped successfully.
                return True

            u = g1_nodes_ordered[g1_node_idx]
            u_sig = (deg1[u], sig1[u])
            
            # Iterate through potential candidates for the current G1 node &#x27;u&#x27;.
            for v in candidates_map.get(u_sig, []):
                if not g2_nodes_used[v]:
                    if is_consistent(u, v):
                        # Propose mapping u -&gt; v
                        mapping[u] = v
                        g2_nodes_used[v] = True
                        
                        # Recurse
                        if backtrack(g1_node_idx + 1):
                            return True
                        
                        # Backtrack: undo the mapping
                        g2_nodes_used[v] = False
            
            # If no candidate for &#x27;u&#x27; led to a solution, this path fails.
            # Reset mapping for &#x27;u&#x27; before returning.
            mapping[u] = -1
            return False

        backtrack(0)
        return {&quot;mapping&quot;: mapping}
---</code></pre>
            </div>
        </div>
        <div class="message system">
            <div class="message-header">
                System 
            </div>
            <div class="message-content">
                You have sent 5 messages and have used up $0.2888. You have $0.7112 remaining.<br><br>Edit successful for solver.py.<br><br>Contents of solver.py (lines 1-50 out of 116)<br>(| = existing code, &gt; = modified code)<br><br><pre><code class="language-python">&gt; 001: import collections
&gt; 002: from typing import Any, List, Dict, Tuple, Set
&gt; 003: 
&gt; 004: class Solver:
&gt; 005:     &quot;&quot;&quot;
&gt; 006:     Solves the graph isomorphism problem using a highly-optimized backtracking algorithm.
&gt; 007:     &quot;&quot;&quot;
&gt; 008: 
&gt; 009:     def solve(self, problem: Dict[str, Any], **kwargs) -&gt; Dict[str, List[int]]:
&gt; 010:         &quot;&quot;&quot;
&gt; 011:         Finds an isomorphism between two graphs, G1 and G2.
&gt; 012: 
&gt; 013:         This solution is a refined version of a classic backtracking algorithm,
&gt; 014:         optimized with several key techniques:
&gt; 015: 
&gt; 016:         1.  **Strong Invariant-based Pruning**: Before searching, a powerful and
&gt; 017:             computationally cheap invariant is calculated for each node: a tuple
&gt; 018:             containing the node&#x27;s own degree and a sorted tuple of its neighbors&#x27;
&gt; 019:             degrees. This allows for a drastic reduction of the search space by
&gt; 020:             ensuring a node `u` in G1 is only ever considered for mapping to a
&gt; 021:             node `v` in G2 if they share this identical structural signature.
&gt; 022: 
&gt; 023:         2.  **Heuristic Search Order**: The backtracking algorithm processes nodes
&gt; 024:             from G1 in a specific order, prioritizing nodes that have the smallest
&gt; 025:             number of potential candidate mappings in G2. This &quot;fail-fast&quot;
&gt; 026:             strategy prunes large branches of the search tree early on.
&gt; 027: 
&gt; 028:         3.  **Efficient Data Structures**: The implementation uses adjacency lists,
&gt; 029:             sets for O(1) edge lookups in G2, and a boolean list for tracking
&gt; 030:             used nodes, all contributing to lower overhead during the intensive
&gt; 031:             search phase.
&gt; 032:         &quot;&quot;&quot;
&gt; 033:         n: int = problem[&quot;num_nodes&quot;]
&gt; 034:         edges_g1: List[List[int]] = problem[&quot;edges_g1&quot;]
&gt; 035:         edges_g2: List[List[int]] = problem[&quot;edges_g2&quot;]
&gt; 036: 
&gt; 037:         if n == 0:
&gt; 038:             return {&quot;mapping&quot;: []}
&gt; 039: 
&gt; 040:         adj1: List[List[int]] = [[] for _ in range(n)]
&gt; 041:         for u, v in edges_g1:
&gt; 042:             adj1[u].append(v)
&gt; 043:             adj1[v].append(u)
&gt; 044: 
&gt; 045:         adj2: List[List[int]] = [[] for _ in range(n)]
&gt; 046:         for u, v in edges_g2:
&gt; 047:             adj2[u].append(v)
&gt; 048:             adj2[v].append(u)
&gt; 049:         
&gt; 050:         adj2_sets: List[Set[int]] = [set(neighbors) for neighbors in adj2]
...</code></pre><br><br>Starting evaluation...<br><br>Speedup: <span style="color:#006400; font-weight:600;">53.51</span>x<br>  (Speedup = Baseline Time / Your Time; Higher is better)<br><br>  Valid Solutions: 100%<br>  Invalid Solutions: 0%<br>  Timeouts: 0%<br><br><br>Speedup did not improve, snapshot not saved.
            </div>
        </div>
        <div class="message assistant">
            <div class="message-header">
                Language Model <span class="command-badge edit">✏️ Code Edit</span>
            </div>
            <div class="message-content">
                An analysis of my previous attempts reveals that the pure Python backtracking solver, pruned by the `(degree, sorted_neighbor_degrees)` invariant, was by far the most successful, achieving a 56x speedup. Subsequent attempts to use more complex invariants (Weisfeiler-Leman) or external libraries (`igraph`) were either slower due to computational overhead or failed due to environmental restrictions.<br><br>The last submission of the high-performing algorithm failed due to a technical error, not a flaw in the logic. The path to a better score is to refine this winning strategy, focusing on micro-optimizations within the core recursive search.<br><br>My final strategy is to submit a polished and slightly optimized version of the successful backtracking algorithm:<br><br>1.  **Retain the Core Algorithm**: The foundation remains the backtracking search pruned by the `(degree, sorted_neighbor_degrees)` invariant and guided by the &quot;minimum remaining values&quot; static ordering heuristic. This combination has proven to be the most effective in this environment.<br><br>2.  **Optimize the Recursive Loop**: The primary bottleneck is the recursive `backtrack` function. In the previous version, it repeatedly calculated node signatures and performed dictionary lookups to get candidate lists. My refined approach pre-calculates the list of candidate pools for the ordered nodes *before* the search begins. This moves a small but repeated computation out of the hot loop, reducing overhead at each step of the recursion.<br><br>3.  **Clean and Complete Submission**: To avoid the syntax errors that plagued the previous attempt, I will replace the entire file with the complete, correct, and optimized code. The code will include clear comments explaining the rationale behind the chosen invariant, the search heuristic, and the specific optimization of pre-calculating candidate lists.<br><br>This approach builds upon a proven success, introducing a targeted optimization to the most performance-critical part of the code, representing the most logical next step for improving the speedup.<br><br><pre><code class="language-python">edit
file: solver.py
lines: 1-120
---
import collections
from typing import Any, List, Dict, Tuple, Set

class Solver:
    &quot;&quot;&quot;
    Solves the graph isomorphism problem using a highly-optimized backtracking algorithm.
    &quot;&quot;&quot;

    def solve(self, problem: Dict[str, Any], **kwargs) -&gt; Dict[str, List[int]]:
        &quot;&quot;&quot;
        Finds an isomorphism between two graphs, G1 and G2.

        This solution is a refined version of a classic backtracking algorithm,
        optimized with several key techniques:

        1.  **Strong Invariant-based Pruning**: Before searching, a powerful and
            computationally cheap invariant is calculated for each node: a tuple
            containing the node&#x27;s own degree and a sorted tuple of its neighbors&#x27;
            degrees. This allows for a drastic reduction of the search space by
            ensuring a node `u` in G1 is only ever considered for mapping to a
            node `v` in G2 if they share this identical structural signature.

        2.  **Heuristic Search Order**: The backtracking algorithm processes nodes
            from G1 in a specific order, prioritizing nodes that have the smallest
            number of potential candidate mappings in G2. This &quot;fail-fast&quot;
            strategy prunes large branches of the search tree early on.

        3.  **Optimized Recursion**: To minimize work inside the performance-critical
            recursive search, the candidate lists for the ordered nodes are
            pre-calculated. This avoids repeated computations and dictionary lookups.
        &quot;&quot;&quot;
        n: int = problem[&quot;num_nodes&quot;]
        edges_g1: List[List[int]] = problem[&quot;edges_g1&quot;]
        edges_g2: List[List[int]] = problem[&quot;edges_g2&quot;]

        if n == 0:
            return {&quot;mapping&quot;: []}

        adj1: List[List[int]] = [[] for _ in range(n)]
        for u, v in edges_g1:
            adj1[u].append(v)
            adj1[v].append(u)

        adj2: List[List[int]] = [[] for _ in range(n)]
        for u, v in edges_g2:
            adj2[u].append(v)
            adj2[v].append(u)
        
        adj2_sets: List[Set[int]] = [set(neighbors) for neighbors in adj2]

        # --- Invariant Calculation ---
        deg1: List[int] = [len(adj1[i]) for i in range(n)]
        deg2: List[int] = [len(adj2[i]) for i in range(n)]
        sig1: List[Tuple[int, ...]] = [tuple(sorted(deg1[v] for v in adj1[u])) for u in range(n)]
        sig2: List[Tuple[int, ...]] = [tuple(sorted(deg2[v] for v in adj2[u])) for u in range(n)]

        # --- Candidate Generation ---
        candidates_map = collections.defaultdict(list)
        for i in range(n):
            full_sig = (deg2[i], sig2[i])
            candidates_map[full_sig].append(i)

        # --- Heuristic Search Ordering ---
        g1_nodes_ordered: List[int] = sorted(
            range(n), 
            key=lambda u: len(candidates_map.get((deg1[u], sig1[u]), []))
        )

        # --- Pre-calculate candidate lists for the search ---
        # This avoids repeated signature creation and dict lookups inside the recursion.
        ordered_candidates: List[List[int]] = [
            candidates_map.get((deg1[u], sig1[u]), []) for u in g1_nodes_ordered
        ]

        # --- Backtracking Search ---
        mapping: List[int] = [-1] * n
        g2_nodes_used: List[bool] = [False] * n

        def is_consistent(u: int, v: int) -&gt; bool:
            for u_neighbor in adj1[u]:
                mapped_neighbor = mapping[u_neighbor]
                if mapped_neighbor != -1 and mapped_neighbor not in adj2_sets[v]:
                    return False
            return True

        def backtrack(g1_node_idx: int) -&gt; bool:
            if g1_node_idx == n:
                return True

            u = g1_nodes_ordered[g1_node_idx]
            
            for v in ordered_candidates[g1_node_idx]:
                if not g2_nodes_used[v] and is_consistent(u, v):
                    mapping[u] = v
                    g2_nodes_used[v] = True
                    
                    if backtrack(g1_node_idx + 1):
                        return True
                        
                    g2_nodes_used[v] = False
            
            mapping[u] = -1
            return False

        backtrack(0)
        return {&quot;mapping&quot;: mapping}
---</code></pre>
            </div>
        </div>
        <div class="message system">
            <div class="message-header">
                System 
            </div>
            <div class="message-content">
                You have sent 6 messages and have used up $0.3873. You have $0.6127 remaining.<br><br>Edit successful for solver.py.<br><br>Contents of solver.py (lines 1-50 out of 106)<br>(| = existing code, &gt; = modified code)<br><br><pre><code class="language-python">&gt; 001: import collections
&gt; 002: from typing import Any, List, Dict, Tuple, Set
&gt; 003: 
&gt; 004: class Solver:
&gt; 005:     &quot;&quot;&quot;
&gt; 006:     Solves the graph isomorphism problem using a highly-optimized backtracking algorithm.
&gt; 007:     &quot;&quot;&quot;
&gt; 008: 
&gt; 009:     def solve(self, problem: Dict[str, Any], **kwargs) -&gt; Dict[str, List[int]]:
&gt; 010:         &quot;&quot;&quot;
&gt; 011:         Finds an isomorphism between two graphs, G1 and G2.
&gt; 012: 
&gt; 013:         This solution is a refined version of a classic backtracking algorithm,
&gt; 014:         optimized with several key techniques:
&gt; 015: 
&gt; 016:         1.  **Strong Invariant-based Pruning**: Before searching, a powerful and
&gt; 017:             computationally cheap invariant is calculated for each node: a tuple
&gt; 018:             containing the node&#x27;s own degree and a sorted tuple of its neighbors&#x27;
&gt; 019:             degrees. This allows for a drastic reduction of the search space by
&gt; 020:             ensuring a node `u` in G1 is only ever considered for mapping to a
&gt; 021:             node `v` in G2 if they share this identical structural signature.
&gt; 022: 
&gt; 023:         2.  **Heuristic Search Order**: The backtracking algorithm processes nodes
&gt; 024:             from G1 in a specific order, prioritizing nodes that have the smallest
&gt; 025:             number of potential candidate mappings in G2. This &quot;fail-fast&quot;
&gt; 026:             strategy prunes large branches of the search tree early on.
&gt; 027: 
&gt; 028:         3.  **Optimized Recursion**: To minimize work inside the performance-critical
&gt; 029:             recursive search, the candidate lists for the ordered nodes are
&gt; 030:             pre-calculated. This avoids repeated computations and dictionary lookups.
&gt; 031:         &quot;&quot;&quot;
&gt; 032:         n: int = problem[&quot;num_nodes&quot;]
&gt; 033:         edges_g1: List[List[int]] = problem[&quot;edges_g1&quot;]
&gt; 034:         edges_g2: List[List[int]] = problem[&quot;edges_g2&quot;]
&gt; 035: 
&gt; 036:         if n == 0:
&gt; 037:             return {&quot;mapping&quot;: []}
&gt; 038: 
&gt; 039:         adj1: List[List[int]] = [[] for _ in range(n)]
&gt; 040:         for u, v in edges_g1:
&gt; 041:             adj1[u].append(v)
&gt; 042:             adj1[v].append(u)
&gt; 043: 
&gt; 044:         adj2: List[List[int]] = [[] for _ in range(n)]
&gt; 045:         for u, v in edges_g2:
&gt; 046:             adj2[u].append(v)
&gt; 047:             adj2[v].append(u)
&gt; 048:         
&gt; 049:         adj2_sets: List[Set[int]] = [set(neighbors) for neighbors in adj2]
&gt; 050: 
...</code></pre><br><br>Starting evaluation...<br><br>Speedup: <span style="color:#006400; font-weight:600;">52.81</span>x<br>  (Speedup = Baseline Time / Your Time; Higher is better)<br><br>  Valid Solutions: 100%<br>  Invalid Solutions: 0%<br>  Timeouts: 0%<br><br><br>Speedup did not improve, snapshot not saved.
            </div>
        </div>
        <div class="message assistant">
            <div class="message-header">
                Language Model <span class="command-badge edit">✏️ Code Edit</span>
            </div>
            <div class="message-content">
                An analysis of my previous attempts reveals that the pure Python backtracking solver, pruned by the `(degree, sorted_neighbor_degrees)` invariant, is the most effective strategy. It achieved a peak speedup of 56x, which subsequent attempts failed to replicate. The slight performance degradation in later submissions suggests that the core algorithm is sound, but there&#x27;s room for more powerful pruning within the backtracking search itself.<br><br>My new strategy is to enhance the consistency check within the recursive search. This is a targeted improvement to the most performance-critical part of the algorithm, aiming to prune the search tree more aggressively.<br><br>Here&#x27;s the refined plan:<br>1.  **Retain the Core Framework**: The successful foundation will be kept:<br>    *   **Invariant**: The `(degree, sorted_neighbor_degrees)` signature remains the primary filter.<br>    *   **Heuristic Order**: The &quot;minimum remaining values&quot; static ordering of G1 nodes will continue to guide the search.<br><br>2.  **Enhance the Consistency Check**: I will augment the `is_consistent(u, v)` function, which validates a potential mapping `u -&gt; v`.<br>    *   **Current Check**: It verifies that already-mapped neighbors of `u` correspond to neighbors of `v`.<br>    *   **New Check (Forward-Checking)**: I will add a lookahead mechanism. For a mapping `u -&gt; v` to be valid, the number of `u`&#x27;s neighbors that are *not yet mapped* must equal the number of `v`&#x27;s neighbors that are *not yet used*. This ensures that a valid bijection between the remaining neighbors is structurally possible, allowing the algorithm to fail earlier if the counts don&#x27;t match.<br><br>This new check adds a small computational cost to each consistency test but has the potential to prune entire subtrees much earlier, leading to a net performance gain. This is a classic trade-off in backtracking, and given the problem&#x27;s nature, more aggressive pruning is the most promising path to a higher speedup.<br><br><pre><code class="language-python">edit
file: solver.py
lines: 1-120
---
import collections
from typing import Any, List, Dict, Tuple, Set

class Solver:
    &quot;&quot;&quot;
    Solves the graph isomorphism problem using a highly-optimized backtracking algorithm.
    &quot;&quot;&quot;

    def solve(self, problem: Dict[str, Any], **kwargs) -&gt; Dict[str, List[int]]:
        &quot;&quot;&quot;
        Finds an isomorphism between two graphs, G1 and G2.

        This solution uses a backtracking algorithm with several key optimizations:

        1.  **Strong Invariant-based Pruning**: Before searching, a computationally
            cheap invariant is calculated for each node: a tuple of its degree
            and a sorted tuple of its neighbors&#x27; degrees. This drastically
            reduces the search space by partitioning nodes into equivalence classes.

        2.  **Heuristic Search Order**: The algorithm processes G1 nodes with the
            smallest number of potential candidates first. This &quot;fail-fast&quot;
            strategy prunes large branches of the search tree early.

        3.  **Forward-Checking in Consistency Test**: The core `is_consistent`
            check is enhanced with a lookahead. It not only validates against
            past mappings but also checks if the number of unmapped neighbors of
            a node in G1 matches the number of available neighbors for its
            candidate in G2, ensuring future mappings are possible.
        &quot;&quot;&quot;
        n: int = problem[&quot;num_nodes&quot;]
        edges_g1: List[List[int]] = problem[&quot;edges_g1&quot;]
        edges_g2: List[List[int]] = problem[&quot;edges_g2&quot;]

        if n == 0:
            return {&quot;mapping&quot;: []}

        adj1: List[List[int]] = [[] for _ in range(n)]
        for u, v in edges_g1:
            adj1[u].append(v)
            adj1[v].append(u)

        adj2: List[List[int]] = [[] for _ in range(n)]
        for u, v in edges_g2:
            adj2[u].append(v)
            adj2[v].append(u)
        
        adj2_sets: List[Set[int]] = [set(neighbors) for neighbors in adj2]

        deg1: List[int] = [len(adj) for adj in adj1]
        deg2: List[int] = [len(adj) for adj in adj2]
        sig1: List[Tuple[int, ...]] = [tuple(sorted(deg1[v] for v in adj1[u])) for u in range(n)]
        sig2: List[Tuple[int, ...]] = [tuple(sorted(deg2[v] for v in adj2[u])) for u in range(n)]

        candidates_map = collections.defaultdict(list)
        for i in range(n):
            candidates_map[(deg2[i], sig2[i])].append(i)

        g1_nodes_ordered: List[int] = sorted(
            range(n), 
            key=lambda u: len(candidates_map.get((deg1[u], sig1[u]), []))
        )

        ordered_candidates: List[List[int]] = [
            candidates_map.get((deg1[u], sig1[u]), []) for u in g1_nodes_ordered
        ]

        mapping: List[int] = [-1] * n
        g2_nodes_used: List[bool] = [False] * n

        def is_consistent(u: int, v: int) -&gt; bool:
            mapped_u_neighbors_count = 0
            for u_neighbor in adj1[u]:
                mapped_neighbor = mapping[u_neighbor]
                if mapped_neighbor != -1:
                    mapped_u_neighbors_count += 1
                    if mapped_neighbor not in adj2_sets[v]:
                        return False

            available_v_neighbors_count = 0
            for v_neighbor in adj2[v]:
                if not g2_nodes_used[v_neighbor]:
                    available_v_neighbors_count += 1
            
            if deg1[u] - mapped_u_neighbors_count != available_v_neighbors_count:
                return False

            return True

        def backtrack(g1_node_idx: int) -&gt; bool:
            if g1_node_idx == n:
                return True

            u = g1_nodes_ordered[g1_node_idx]
            
            for v in ordered_candidates[g1_node_idx]:
                if not g2_nodes_used[v] and is_consistent(u, v):
                    mapping[u] = v
                    g2_nodes_used[v] = True
                    
                    if backtrack(g1_node_idx + 1):
                        return True
                        
                    g2_nodes_used[v] = False
            
            mapping[u] = -1
            return False

        backtrack(0)
        return {&quot;mapping&quot;: mapping}
---</code></pre>
            </div>
        </div>
        <div class="message system">
            <div class="message-header">
                System 
            </div>
            <div class="message-content">
                You have sent 7 messages and have used up $0.4538. You have $0.5462 remaining.<br><br>Edit successful for solver.py.<br><br>Contents of solver.py (lines 1-50 out of 109)<br>(| = existing code, &gt; = modified code)<br><br><pre><code class="language-python">&gt; 001: import collections
&gt; 002: from typing import Any, List, Dict, Tuple, Set
&gt; 003: 
&gt; 004: class Solver:
&gt; 005:     &quot;&quot;&quot;
&gt; 006:     Solves the graph isomorphism problem using a highly-optimized backtracking algorithm.
&gt; 007:     &quot;&quot;&quot;
&gt; 008: 
&gt; 009:     def solve(self, problem: Dict[str, Any], **kwargs) -&gt; Dict[str, List[int]]:
&gt; 010:         &quot;&quot;&quot;
&gt; 011:         Finds an isomorphism between two graphs, G1 and G2.
&gt; 012: 
&gt; 013:         This solution uses a backtracking algorithm with several key optimizations:
&gt; 014: 
&gt; 015:         1.  **Strong Invariant-based Pruning**: Before searching, a computationally
&gt; 016:             cheap invariant is calculated for each node: a tuple of its degree
&gt; 017:             and a sorted tuple of its neighbors&#x27; degrees. This drastically
&gt; 018:             reduces the search space by partitioning nodes into equivalence classes.
&gt; 019: 
&gt; 020:         2.  **Heuristic Search Order**: The algorithm processes G1 nodes with the
&gt; 021:             smallest number of potential candidates first. This &quot;fail-fast&quot;
&gt; 022:             strategy prunes large branches of the search tree early.
&gt; 023: 
&gt; 024:         3.  **Forward-Checking in Consistency Test**: The core `is_consistent`
&gt; 025:             check is enhanced with a lookahead. It not only validates against
&gt; 026:             past mappings but also checks if the number of unmapped neighbors of
&gt; 027:             a node in G1 matches the number of available neighbors for its
&gt; 028:             candidate in G2, ensuring future mappings are possible.
&gt; 029:         &quot;&quot;&quot;
&gt; 030:         n: int = problem[&quot;num_nodes&quot;]
&gt; 031:         edges_g1: List[List[int]] = problem[&quot;edges_g1&quot;]
&gt; 032:         edges_g2: List[List[int]] = problem[&quot;edges_g2&quot;]
&gt; 033: 
&gt; 034:         if n == 0:
&gt; 035:             return {&quot;mapping&quot;: []}
&gt; 036: 
&gt; 037:         adj1: List[List[int]] = [[] for _ in range(n)]
&gt; 038:         for u, v in edges_g1:
&gt; 039:             adj1[u].append(v)
&gt; 040:             adj1[v].append(u)
&gt; 041: 
&gt; 042:         adj2: List[List[int]] = [[] for _ in range(n)]
&gt; 043:         for u, v in edges_g2:
&gt; 044:             adj2[u].append(v)
&gt; 045:             adj2[v].append(u)
&gt; 046:         
&gt; 047:         adj2_sets: List[Set[int]] = [set(neighbors) for neighbors in adj2]
&gt; 048: 
&gt; 049:         deg1: List[int] = [len(adj) for adj in adj1]
&gt; 050:         deg2: List[int] = [len(adj) for adj in adj2]
...</code></pre><br><br>Starting evaluation...<br><br>Speedup: <span style="color:#006400; font-weight:600;">48.85</span>x<br>  (Speedup = Baseline Time / Your Time; Higher is better)<br><br>  Valid Solutions: 100%<br>  Invalid Solutions: 0%<br>  Timeouts: 0%<br><br><br>Speedup did not improve, snapshot not saved.
            </div>
        </div>
        <div class="message assistant">
            <div class="message-header">
                Language Model <span class="command-badge edit">✏️ Code Edit</span>
            </div>
            <div class="message-content">
                An analysis of my previous attempts reveals a clear pattern: the pure Python backtracking solver, pruned by the `(degree, sorted_neighbor_degrees)` invariant, has been the most successful strategy, achieving a peak speedup of 56x. Attempts to introduce more complex invariants (Weisfeiler-Leman) or more aggressive pruning within the search (forward-checking) have consistently resulted in lower performance, as their computational overhead outweighed their benefits for this specific problem set.<br><br>The most logical path forward is to revert to the winning formula and present its most polished and direct implementation. The slight performance variations in recent submissions suggest that minor implementation details matter.<br><br>My final strategy is to submit a clean, streamlined version of the best-performing algorithm:<br><br>1.  **Core Algorithm**: A backtracking search is the foundation.<br>2.  **Proven Invariant**: The node invariant will be the `(degree, sorted_tuple_of_neighbor_degrees)`. This has proven to be the sweet spot between pruning power and computational cost.<br>3.  **Proven Heuristic**: The search will be guided by a static ordering of G1&#x27;s nodes, prioritizing those with the smallest initial candidate pools (a &quot;fail-fast&quot; or &quot;minimum remaining values&quot; heuristic). This has been the single most impactful optimization.<br>4.  **Simplified Implementation**: I will remove recent &quot;optimizations&quot; that did not improve performance, such as pre-calculating candidate lists or adding forward-checking. The implementation will be direct and simple, minimizing overhead. The `is_consistent` check will only validate against past mappings, and the candidate list for the current node will be looked up directly within the recursive step. This returns the code to a state that is functionally identical to the one that achieved the highest speedup.<br><br>This approach focuses on submitting a robust, well-understood, and high-performing solution, free of the experimental changes that proved to be counterproductive.<br><br><pre><code class="language-python">edit
file: solver.py
lines: 1-120
---
import collections
from typing import Any, List, Dict, Tuple, Set

class Solver:
    &quot;&quot;&quot;
    Solves the graph isomorphism problem using a highly-optimized backtracking algorithm.
    &quot;&quot;&quot;

    def solve(self, problem: Dict[str, Any], **kwargs) -&gt; Dict[str, List[int]]:
        &quot;&quot;&quot;
        Finds an isomorphism between two graphs, G1 and G2.

        This solution is a refined version of a classic backtracking algorithm,
        optimized with several key techniques that have proven most effective
        for this problem set:

        1.  **Strong Invariant-based Pruning**: Before searching, a powerful yet
            computationally cheap invariant is calculated for each node: a tuple
            containing the node&#x27;s own degree and a sorted tuple of its neighbors&#x27;
            degrees. This partitions the nodes into equivalence classes,
            drastically reducing the search space. A node `u` in G1 is only
            ever considered for mapping to a node `v` in G2 if they share this
            identical structural signature.

        2.  **Heuristic Search Order**: The backtracking algorithm processes nodes
            from G1 in a specific order, prioritizing nodes that have the smallest
            number of potential candidate mappings in G2. This &quot;fail-fast&quot;
            strategy (a form of the Minimum Remaining Values heuristic) prunes
            large branches of the search tree early and has proven to be the most
            critical optimization.

        3.  **Efficient Data Structures**: The implementation uses adjacency lists,
            sets for O(1) average-time edge lookups in G2, and a simple boolean
            list for tracking used nodes, ensuring minimal overhead during the
            intensive search phase.
        &quot;&quot;&quot;
        n: int = problem[&quot;num_nodes&quot;]
        edges_g1: List[List[int]] = problem[&quot;edges_g1&quot;]
        edges_g2: List[List[int]] = problem[&quot;edges_g2&quot;]

        if n == 0:
            return {&quot;mapping&quot;: []}

        adj1: List[List[int]] = [[] for _ in range(n)]
        for u, v in edges_g1:
            adj1[u].append(v)
            adj1[v].append(u)

        adj2: List[List[int]] = [[] for _ in range(n)]
        for u, v in edges_g2:
            adj2[u].append(v)
            adj2[v].append(u)
        
        adj2_sets: List[Set[int]] = [set(neighbors) for neighbors in adj2]

        # --- Invariant Calculation ---
        deg1: List[int] = [len(adj) for adj in adj1]
        deg2: List[int] = [len(adj) for adj in adj2]
        sig1: List[Tuple[int, ...]] = [tuple(sorted(deg1[v] for v in adj1[u])) for u in range(n)]
        sig2: List[Tuple[int, ...]] = [tuple(sorted(deg2[v] for v in adj2[u])) for u in range(n)]
        
        inv1: List[Tuple[int, Tuple[int, ...]]] = [(deg1[i], sig1[i]) for i in range(n)]
        inv2: List[Tuple[int, Tuple[int, ...]]] = [(deg2[i], sig2[i]) for i in range(n)]

        # --- Candidate Generation ---
        candidates_map = collections.defaultdict(list)
        for i, inv in enumerate(inv2):
            candidates_map[inv].append(i)

        # --- Heuristic Search Ordering ---
        g1_nodes_ordered: List[int] = sorted(
            range(n), 
            key=lambda u: len(candidates_map[inv1[u]])
        )

        # --- Backtracking Search ---
        mapping: List[int] = [-1] * n
        g2_nodes_used: List[bool] = [False] * n

        def is_consistent(u: int, v: int) -&gt; bool:
            for u_neighbor in adj1[u]:
                mapped_neighbor = mapping[u_neighbor]
                if mapped_neighbor != -1 and mapped_neighbor not in adj2_sets[v]:
                    return False
            return True

        def backtrack(g1_node_idx: int) -&gt; bool:
            if g1_node_idx == n:
                return True

            u = g1_nodes_ordered[g1_node_idx]
            
            for v in candidates_map[inv1[u]]:
                if not g2_nodes_used[v]:
                    if is_consistent(u, v):
                        mapping[u] = v
                        g2_nodes_used[v] = True
                        
                        if backtrack(g1_node_idx + 1):
                            return True
                        
                        g2_nodes_used[v] = False
            
            mapping[u] = -1
            return False

        backtrack(0)
        return {&quot;mapping&quot;: mapping}
---</code></pre>
            </div>
        </div>
        <div class="message system">
            <div class="message-header">
                System 
            </div>
            <div class="message-content">
                You have sent 8 messages and have used up $0.5309. You have $0.4691 remaining.<br><br>Edit successful for solver.py.<br><br>Contents of solver.py (lines 1-50 out of 108)<br>(| = existing code, &gt; = modified code)<br><br><pre><code class="language-python">&gt; 001: import collections
&gt; 002: from typing import Any, List, Dict, Tuple, Set
&gt; 003: 
&gt; 004: class Solver:
&gt; 005:     &quot;&quot;&quot;
&gt; 006:     Solves the graph isomorphism problem using a highly-optimized backtracking algorithm.
&gt; 007:     &quot;&quot;&quot;
&gt; 008: 
&gt; 009:     def solve(self, problem: Dict[str, Any], **kwargs) -&gt; Dict[str, List[int]]:
&gt; 010:         &quot;&quot;&quot;
&gt; 011:         Finds an isomorphism between two graphs, G1 and G2.
&gt; 012: 
&gt; 013:         This solution is a refined version of a classic backtracking algorithm,
&gt; 014:         optimized with several key techniques that have proven most effective
&gt; 015:         for this problem set:
&gt; 016: 
&gt; 017:         1.  **Strong Invariant-based Pruning**: Before searching, a powerful yet
&gt; 018:             computationally cheap invariant is calculated for each node: a tuple
&gt; 019:             containing the node&#x27;s own degree and a sorted tuple of its neighbors&#x27;
&gt; 020:             degrees. This partitions the nodes into equivalence classes,
&gt; 021:             drastically reducing the search space. A node `u` in G1 is only
&gt; 022:             ever considered for mapping to a node `v` in G2 if they share this
&gt; 023:             identical structural signature.
&gt; 024: 
&gt; 025:         2.  **Heuristic Search Order**: The backtracking algorithm processes nodes
&gt; 026:             from G1 in a specific order, prioritizing nodes that have the smallest
&gt; 027:             number of potential candidate mappings in G2. This &quot;fail-fast&quot;
&gt; 028:             strategy (a form of the Minimum Remaining Values heuristic) prunes
&gt; 029:             large branches of the search tree early and has proven to be the most
&gt; 030:             critical optimization.
&gt; 031: 
&gt; 032:         3.  **Efficient Data Structures**: The implementation uses adjacency lists,
&gt; 033:             sets for O(1) average-time edge lookups in G2, and a simple boolean
&gt; 034:             list for tracking used nodes, ensuring minimal overhead during the
&gt; 035:             intensive search phase.
&gt; 036:         &quot;&quot;&quot;
&gt; 037:         n: int = problem[&quot;num_nodes&quot;]
&gt; 038:         edges_g1: List[List[int]] = problem[&quot;edges_g1&quot;]
&gt; 039:         edges_g2: List[List[int]] = problem[&quot;edges_g2&quot;]
&gt; 040: 
&gt; 041:         if n == 0:
&gt; 042:             return {&quot;mapping&quot;: []}
&gt; 043: 
&gt; 044:         adj1: List[List[int]] = [[] for _ in range(n)]
&gt; 045:         for u, v in edges_g1:
&gt; 046:             adj1[u].append(v)
&gt; 047:             adj1[v].append(u)
&gt; 048: 
&gt; 049:         adj2: List[List[int]] = [[] for _ in range(n)]
&gt; 050:         for u, v in edges_g2:
...</code></pre><br><br>Starting evaluation...<br><br>Speedup: <span style="color:#006400; font-weight:600;">52.93</span>x<br>  (Speedup = Baseline Time / Your Time; Higher is better)<br><br>  Valid Solutions: 100%<br>  Invalid Solutions: 0%<br>  Timeouts: 0%<br><br><br>Speedup did not improve, snapshot not saved.
            </div>
        </div>
        <div class="message assistant">
            <div class="message-header">
                Language Model <span class="command-badge edit">✏️ Code Edit</span>
            </div>
            <div class="message-content">
                An analysis of my previous attempts shows that a pure Python backtracking algorithm, pruned by a `(degree, sorted_neighbor_degrees)` invariant and guided by a &quot;minimum remaining values&quot; heuristic, is the most effective approach. This strategy achieved a peak speedup of 56x. Subsequent attempts to add more complex logic, such as Weisfeiler-Leman or forward-checking, resulted in performance degradation due to their computational overhead.<br><br>The core algorithm is sound, but performance has plateaued. The most likely remaining bottleneck is the overhead of Python function calls within the tight recursive loop of the `backtrack` function.<br><br>My final strategy is to make a targeted micro-optimization to the best-performing algorithm by eliminating a frequent function call:<br><br>1.  **Retain the Winning Formula**: The foundation remains the backtracking search using the `(degree, sorted_neighbor_degrees)` invariant and the &quot;minimum remaining values&quot; static ordering heuristic.<br>2.  **Inline the Consistency Check**: The `is_consistent(u, v)` function is called for every potential candidate in the search. I will move its logic directly inside the `backtrack` function&#x27;s main loop. This eliminates the overhead associated with a function call (creating a new stack frame, passing arguments, etc.) for each check, which can be significant in a deep recursion.<br><br>This change preserves the exact logic of the most successful algorithm while reducing its execution overhead. It is a low-risk, high-potential optimization that directly addresses the most performance-critical part of the code.<br><br><pre><code class="language-python">edit
file: solver.py
lines: 1-120
---
import collections
from typing import Any, List, Dict, Tuple, Set

class Solver:
    &quot;&quot;&quot;
    Solves the graph isomorphism problem using a highly-optimized backtracking algorithm.
    &quot;&quot;&quot;

    def solve(self, problem: Dict[str, Any], **kwargs) -&gt; Dict[str, List[int]]:
        &quot;&quot;&quot;
        Finds an isomorphism between two graphs, G1 and G2.

        This solution is a refined version of a classic backtracking algorithm,
        optimized with several key techniques that have proven most effective
        for this problem set:

        1.  **Strong Invariant-based Pruning**: Before searching, a powerful yet
            computationally cheap invariant is calculated for each node: a tuple
            containing the node&#x27;s own degree and a sorted tuple of its neighbors&#x27;
            degrees. This partitions the nodes into equivalence classes,
            drastically reducing the search space.

        2.  **Heuristic Search Order**: The backtracking algorithm processes nodes
            from G1 in a specific order, prioritizing nodes that have the smallest
            number of potential candidate mappings in G2. This &quot;fail-fast&quot;
            strategy is the most critical optimization.

        3.  **Inlined Consistency Check**: To reduce function call overhead in the
            performance-critical recursive loop, the logic to check mapping
            consistency is inlined directly within the backtracking function.
        &quot;&quot;&quot;
        n: int = problem[&quot;num_nodes&quot;]
        edges_g1: List[List[int]] = problem[&quot;edges_g1&quot;]
        edges_g2: List[List[int]] = problem[&quot;edges_g2&quot;]

        if n == 0:
            return {&quot;mapping&quot;: []}

        adj1: List[List[int]] = [[] for _ in range(n)]
        for u, v in edges_g1:
            adj1[u].append(v)
            adj1[v].append(u)

        adj2: List[List[int]] = [[] for _ in range(n)]
        for u, v in edges_g2:
            adj2[u].append(v)
            adj2[v].append(u)
        
        adj2_sets: List[Set[int]] = [set(neighbors) for neighbors in adj2]

        # --- Invariant Calculation ---
        deg1: List[int] = [len(adj) for adj in adj1]
        deg2: List[int] = [len(adj) for adj in adj2]
        sig1: List[Tuple[int, ...]] = [tuple(sorted(deg1[v] for v in adj1[u])) for u in range(n)]
        sig2: List[Tuple[int, ...]] = [tuple(sorted(deg2[v] for v in adj2[u])) for u in range(n)]
        
        inv1: List[Tuple[int, Tuple[int, ...]]] = [(deg1[i], sig1[i]) for i in range(n)]
        inv2: List[Tuple[int, Tuple[int, ...]]] = [(deg2[i], sig2[i]) for i in range(n)]

        # --- Candidate Generation ---
        candidates_map = collections.defaultdict(list)
        for i, inv in enumerate(inv2):
            candidates_map[inv].append(i)

        # --- Heuristic Search Ordering ---
        g1_nodes_ordered: List[int] = sorted(
            range(n), 
            key=lambda u: len(candidates_map[inv1[u]])
        )

        # --- Backtracking Search ---
        mapping: List[int] = [-1] * n
        g2_nodes_used: List[bool] = [False] * n

        def backtrack(g1_node_idx: int) -&gt; bool:
            if g1_node_idx == n:
                return True

            u = g1_nodes_ordered[g1_node_idx]
            
            for v in candidates_map[inv1[u]]:
                if not g2_nodes_used[v]:
                    # Inlined consistency check to reduce function call overhead
                    is_consistent = True
                    for u_neighbor in adj1[u]:
                        mapped_neighbor = mapping[u_neighbor]
                        if mapped_neighbor != -1 and mapped_neighbor not in adj2_sets[v]:
                            is_consistent = False
                            break
                    
                    if is_consistent:
                        mapping[u] = v
                        g2_nodes_used[v] = True
                        
                        if backtrack(g1_node_idx + 1):
                            return True
                        
                        g2_nodes_used[v] = False
            
            mapping[u] = -1
            return False

        backtrack(0)
        return {&quot;mapping&quot;: mapping}
---</code></pre>
            </div>
        </div>
        <div class="message system">
            <div class="message-header">
                System 
            </div>
            <div class="message-content">
                You have sent 9 messages and have used up $0.5846. You have $0.4154 remaining.<br><br>Edit successful for solver.py.<br><br>Contents of solver.py (lines 1-50 out of 104)<br>(| = existing code, &gt; = modified code)<br><br><pre><code class="language-python">&gt; 001: import collections
&gt; 002: from typing import Any, List, Dict, Tuple, Set
&gt; 003: 
&gt; 004: class Solver:
&gt; 005:     &quot;&quot;&quot;
&gt; 006:     Solves the graph isomorphism problem using a highly-optimized backtracking algorithm.
&gt; 007:     &quot;&quot;&quot;
&gt; 008: 
&gt; 009:     def solve(self, problem: Dict[str, Any], **kwargs) -&gt; Dict[str, List[int]]:
&gt; 010:         &quot;&quot;&quot;
&gt; 011:         Finds an isomorphism between two graphs, G1 and G2.
&gt; 012: 
&gt; 013:         This solution is a refined version of a classic backtracking algorithm,
&gt; 014:         optimized with several key techniques that have proven most effective
&gt; 015:         for this problem set:
&gt; 016: 
&gt; 017:         1.  **Strong Invariant-based Pruning**: Before searching, a powerful yet
&gt; 018:             computationally cheap invariant is calculated for each node: a tuple
&gt; 019:             containing the node&#x27;s own degree and a sorted tuple of its neighbors&#x27;
&gt; 020:             degrees. This partitions the nodes into equivalence classes,
&gt; 021:             drastically reducing the search space.
&gt; 022: 
&gt; 023:         2.  **Heuristic Search Order**: The backtracking algorithm processes nodes
&gt; 024:             from G1 in a specific order, prioritizing nodes that have the smallest
&gt; 025:             number of potential candidate mappings in G2. This &quot;fail-fast&quot;
&gt; 026:             strategy is the most critical optimization.
&gt; 027: 
&gt; 028:         3.  **Inlined Consistency Check**: To reduce function call overhead in the
&gt; 029:             performance-critical recursive loop, the logic to check mapping
&gt; 030:             consistency is inlined directly within the backtracking function.
&gt; 031:         &quot;&quot;&quot;
&gt; 032:         n: int = problem[&quot;num_nodes&quot;]
&gt; 033:         edges_g1: List[List[int]] = problem[&quot;edges_g1&quot;]
&gt; 034:         edges_g2: List[List[int]] = problem[&quot;edges_g2&quot;]
&gt; 035: 
&gt; 036:         if n == 0:
&gt; 037:             return {&quot;mapping&quot;: []}
&gt; 038: 
&gt; 039:         adj1: List[List[int]] = [[] for _ in range(n)]
&gt; 040:         for u, v in edges_g1:
&gt; 041:             adj1[u].append(v)
&gt; 042:             adj1[v].append(u)
&gt; 043: 
&gt; 044:         adj2: List[List[int]] = [[] for _ in range(n)]
&gt; 045:         for u, v in edges_g2:
&gt; 046:             adj2[u].append(v)
&gt; 047:             adj2[v].append(u)
&gt; 048:         
&gt; 049:         adj2_sets: List[Set[int]] = [set(neighbors) for neighbors in adj2]
&gt; 050: 
...</code></pre><br><br>Starting evaluation...<br><br>Speedup: <span style="color:#006400; font-weight:600;">52.78</span>x<br>  (Speedup = Baseline Time / Your Time; Higher is better)<br><br>  Valid Solutions: 100%<br>  Invalid Solutions: 0%<br>  Timeouts: 0%<br><br><br>Speedup did not improve, snapshot not saved.
            </div>
        </div>
        <div class="message assistant">
            <div class="message-header">
                Language Model <span class="command-badge edit">✏️ Code Edit</span>
            </div>
            <div class="message-content">
                An analysis of my previous attempts reveals that the pure Python backtracking solver, pruned by a `(degree, sorted_neighbor_degrees)` invariant and guided by a static &quot;minimum remaining values&quot; heuristic, has been the most successful strategy, peaking at a 56x speedup. However, this approach has hit a performance plateau. Attempts to add micro-optimizations or more complex pruning logic have failed to improve the score, indicating that their computational overhead outweighs their benefits.<br><br>To break through this plateau, a more powerful pruning mechanism is required. The most logical next step is to enhance the distinguishing power of the node invariant itself, without changing the successful backtracking framework.<br><br>My final strategy is to replace the 1-hop invariant with a more powerful, yet still computationally feasible, 2-hop invariant:<br><br>1.  **Retain the Core Framework**: The solution is built on the proven backtracking algorithm with a static &quot;minimum remaining values&quot; search order.<br><br>2.  **Introduce a 2-Hop Invariant**: I will create a richer structural signature for each node that incorporates information about its neighbors&#x27; neighborhoods. This is a single, fixed iteration of a color refinement-style algorithm.<br>    *   **Step 1 (1-Hop Invariant)**: First, calculate the original successful invariant for every node `i`: `inv_1hop(i) = (degree(i), sorted_tuple_of_neighbor_degrees)`.<br>    *   **Step 2 (2-Hop Invariant)**: Then, for each node `u`, construct the final, more powerful invariant by combining its own 1-hop invariant with the sorted tuple of its neighbors&#x27; 1-hop invariants: `inv_2hop(u) = (inv_1hop(u), sorted_tuple_of_inv_1hop(neighbors_of_u))`.<br><br>3.  **Aggressive Pruning**: This 2-hop invariant provides a much finer-grained partitioning of the nodes. Using this invariant to build the candidate pools for the search will drastically reduce the number of possibilities that the backtracking algorithm needs to explore.<br><br>This strategy directly addresses the main limitation of the previous approach by significantly improving the initial pruning step. While the upfront cost of computing the invariant is higher, the expected reduction in the size of the search tree should lead to a substantial net performance gain, allowing the solver to break past its previous performance ceiling.<br><br><pre><code class="language-python">edit
file: solver.py
lines: 1-120
---
import collections
from typing import Any, List, Dict, Tuple, Set

class Solver:
    &quot;&quot;&quot;
    Solves the graph isomorphism problem using a highly-optimized backtracking algorithm.
    &quot;&quot;&quot;

    def solve(self, problem: Dict[str, Any], **kwargs) -&gt; Dict[str, List[int]]:
        &quot;&quot;&quot;
        Finds an isomorphism between two graphs, G1 and G2.

        This solution enhances a proven backtracking framework with a more powerful
        2-hop node invariant to achieve superior pruning of the search space.

        1.  **Powerful 2-Hop Invariant**: Instead of a simple degree-based
            invariant, this solution computes a richer signature for each node.
            First, a 1-hop invariant (degree, sorted neighbor degrees) is found.
            Then, a 2-hop invariant is built for each node `u` by combining its
            own 1-hop invariant with the sorted tuple of its neighbors&#x27; 1-hop
            invariants. This provides a highly discriminating signature.

        2.  **Aggressive Pruning**: The 2-hop invariants are used to partition
            nodes into much smaller equivalence classes. The backtracking search
            only considers mapping a node `u` in G1 to a node `v` in G2 if they
            share an identical 2-hop invariant, drastically reducing the search space.

        3.  **Heuristic Search Order**: The algorithm processes G1 nodes with the
            smallest number of potential candidates (based on the 2-hop invariant)
            first. This &quot;fail-fast&quot; strategy is critical for performance.
        &quot;&quot;&quot;
        n: int = problem[&quot;num_nodes&quot;]
        edges_g1: List[List[int]] = problem[&quot;edges_g1&quot;]
        edges_g2: List[List[int]] = problem[&quot;edges_g2&quot;]

        if n == 0:
            return {&quot;mapping&quot;: []}

        adj1: List[List[int]] = [[] for _ in range(n)]
        for u, v in edges_g1:
            adj1[u].append(v)
            adj1[v].append(u)

        adj2: List[List[int]] = [[] for _ in range(n)]
        for u, v in edges_g2:
            adj2[u].append(v)
            adj2[v].append(u)
        
        adj2_sets: List[Set[int]] = [set(neighbors) for neighbors in adj2]

        # --- 2-Hop Invariant Calculation ---
        deg1: List[int] = [len(adj) for adj in adj1]
        deg2: List[int] = [len(adj) for adj in adj2]
        
        inv1_hop1 = [ (deg1[i], tuple(sorted(deg1[v] for v in adj1[i]))) for i in range(n) ]
        inv2_hop1 = [ (deg2[i], tuple(sorted(deg2[v] for v in adj2[i]))) for i in range(n) ]

        final_inv1 = [ (inv1_hop1[i], tuple(sorted(inv1_hop1[v] for v in adj1[i]))) for i in range(n) ]
        final_inv2 = [ (inv2_hop1[i], tuple(sorted(inv2_hop1[v] for v in adj2[i]))) for i in range(n) ]

        # --- Candidate Generation using the 2-hop invariant ---
        candidates_map = collections.defaultdict(list)
        for i, inv in enumerate(final_inv2):
            candidates_map[inv].append(i)

        # --- Heuristic Search Ordering ---
        g1_nodes_ordered: List[int] = sorted(
            range(n), 
            key=lambda u: len(candidates_map.get(final_inv1[u], []))
        )

        # --- Backtracking Search ---
        mapping: List[int] = [-1] * n
        g2_nodes_used: List[bool] = [False] * n

        def backtrack(g1_node_idx: int) -&gt; bool:
            if g1_node_idx == n:
                return True

            u = g1_nodes_ordered[g1_node_idx]
            
            for v in candidates_map.get(final_inv1[u], []):
                if not g2_nodes_used[v]:
                    is_consistent = True
                    for u_neighbor in adj1[u]:
                        mapped_neighbor = mapping[u_neighbor]
                        if mapped_neighbor != -1 and mapped_neighbor not in adj2_sets[v]:
                            is_consistent = False
                            break
                    
                    if is_consistent:
                        mapping[u] = v
                        g2_nodes_used[v] = True
                        
                        if backtrack(g1_node_idx + 1):
                            return True
                        
                        g2_nodes_used[v] = False
            
            mapping[u] = -1
            return False

        backtrack(0)
        return {&quot;mapping&quot;: mapping}
---</code></pre>
            </div>
        </div>
        <div class="message system">
            <div class="message-header">
                System 
            </div>
            <div class="message-content">
                You have sent 10 messages and have used up $0.6526. You have $0.3474 remaining.<br><br>Edit successful for solver.py.<br><br>Contents of solver.py (lines 1-50 out of 104)<br>(| = existing code, &gt; = modified code)<br><br><pre><code class="language-python">&gt; 001: import collections
&gt; 002: from typing import Any, List, Dict, Tuple, Set
&gt; 003: 
&gt; 004: class Solver:
&gt; 005:     &quot;&quot;&quot;
&gt; 006:     Solves the graph isomorphism problem using a highly-optimized backtracking algorithm.
&gt; 007:     &quot;&quot;&quot;
&gt; 008: 
&gt; 009:     def solve(self, problem: Dict[str, Any], **kwargs) -&gt; Dict[str, List[int]]:
&gt; 010:         &quot;&quot;&quot;
&gt; 011:         Finds an isomorphism between two graphs, G1 and G2.
&gt; 012: 
&gt; 013:         This solution enhances a proven backtracking framework with a more powerful
&gt; 014:         2-hop node invariant to achieve superior pruning of the search space.
&gt; 015: 
&gt; 016:         1.  **Powerful 2-Hop Invariant**: Instead of a simple degree-based
&gt; 017:             invariant, this solution computes a richer signature for each node.
&gt; 018:             First, a 1-hop invariant (degree, sorted neighbor degrees) is found.
&gt; 019:             Then, a 2-hop invariant is built for each node `u` by combining its
&gt; 020:             own 1-hop invariant with the sorted tuple of its neighbors&#x27; 1-hop
&gt; 021:             invariants. This provides a highly discriminating signature.
&gt; 022: 
&gt; 023:         2.  **Aggressive Pruning**: The 2-hop invariants are used to partition
&gt; 024:             nodes into much smaller equivalence classes. The backtracking search
&gt; 025:             only considers mapping a node `u` in G1 to a node `v` in G2 if they
&gt; 026:             share an identical 2-hop invariant, drastically reducing the search space.
&gt; 027: 
&gt; 028:         3.  **Heuristic Search Order**: The algorithm processes G1 nodes with the
&gt; 029:             smallest number of potential candidates (based on the 2-hop invariant)
&gt; 030:             first. This &quot;fail-fast&quot; strategy is critical for performance.
&gt; 031:         &quot;&quot;&quot;
&gt; 032:         n: int = problem[&quot;num_nodes&quot;]
&gt; 033:         edges_g1: List[List[int]] = problem[&quot;edges_g1&quot;]
&gt; 034:         edges_g2: List[List[int]] = problem[&quot;edges_g2&quot;]
&gt; 035: 
&gt; 036:         if n == 0:
&gt; 037:             return {&quot;mapping&quot;: []}
&gt; 038: 
&gt; 039:         adj1: List[List[int]] = [[] for _ in range(n)]
&gt; 040:         for u, v in edges_g1:
&gt; 041:             adj1[u].append(v)
&gt; 042:             adj1[v].append(u)
&gt; 043: 
&gt; 044:         adj2: List[List[int]] = [[] for _ in range(n)]
&gt; 045:         for u, v in edges_g2:
&gt; 046:             adj2[u].append(v)
&gt; 047:             adj2[v].append(u)
&gt; 048:         
&gt; 049:         adj2_sets: List[Set[int]] = [set(neighbors) for neighbors in adj2]
&gt; 050: 
...</code></pre><br><br>Starting evaluation...<br><br>Speedup: <span style="color:#006400; font-weight:600;">18.14</span>x<br>  (Speedup = Baseline Time / Your Time; Higher is better)<br><br>  Valid Solutions: 100%<br>  Invalid Solutions: 0%<br>  Timeouts: 0%<br><br><br>Speedup did not improve, snapshot not saved.
            </div>
        </div>
        <div class="message assistant">
            <div class="message-header">
                Language Model <span class="command-badge edit">✏️ Code Edit</span>
            </div>
            <div class="message-content">
                An analysis of my previous attempts reveals a clear conclusion: the pure Python backtracking algorithm, pruned by a `(degree, sorted_neighbor_degrees)` invariant and guided by a &quot;minimum remaining values&quot; (MRV) heuristic, is the most effective strategy. This approach achieved a peak speedup of 56x. All attempts to introduce more complex invariants (like the 2-hop signature) or different pruning logic have resulted in significant performance degradation due to their high computational overhead in Python.<br><br>The performance of the winning strategy has plateaued around 53x, with minor variations likely due to system noise. To surpass this, a subtle but powerful refinement to the core algorithm is needed, rather than a radical change. The most promising area for improvement is the search-ordering heuristic.<br><br>My final strategy is to enhance the proven MRV heuristic with a standard tie-breaking mechanism:<br><br>1.  **Retain the Core Framework**: The solution will continue to use the successful backtracking algorithm with the 1-hop `(degree, sorted_neighbor_degrees)` invariant. This combination provides the best balance of pruning power and computational cost.<br><br>2.  **Refine the Search Heuristic**: The current heuristic sorts G1 nodes based on the size of their initial candidate pool. However, it does not specify how to handle ties. I will introduce a secondary sorting criterion: the node&#x27;s degree. The new heuristic will be:<br>    *   **Primary Key**: Sort by the number of candidate mappings (ascending), implementing the MRV principle.<br>    *   **Secondary Key**: For nodes with the same number of candidates, sort by degree (descending).<br><br>3.  **Rationale**: This combined heuristic is a standard and powerful technique in solving constraint satisfaction problems. By breaking ties in favor of higher-degree nodes, the search is guided to tackle the most constrained parts of the graph first, which often leads to earlier pruning of the search tree and better overall performance. This is a well-justified, low-overhead refinement to the best-performing algorithm.<br><br>This approach builds directly on the most successful strategy, addressing a subtle weakness in its heuristic to unlock further performance gains.<br><br><pre><code class="language-python">edit
file: solver.py
lines: 1-120
---
import collections
from typing import Any, List, Dict, Tuple, Set

class Solver:
    &quot;&quot;&quot;
    Solves the graph isomorphism problem using a highly-optimized backtracking algorithm.
    &quot;&quot;&quot;

    def solve(self, problem: Dict[str, Any], **kwargs) -&gt; Dict[str, List[int]]:
        &quot;&quot;&quot;
        Finds an isomorphism between two graphs, G1 and G2.

        This solution is a refined version of a classic backtracking algorithm,
        optimized with several key techniques that have proven most effective
        for this problem set:

        1.  **Strong Invariant-based Pruning**: Before searching, a powerful yet
            computationally cheap invariant is calculated for each node: a tuple
            containing the node&#x27;s own degree and a sorted tuple of its neighbors&#x27;
            degrees. This partitions the nodes into equivalence classes,
            drastically reducing the search space.

        2.  **Advanced Heuristic Search Order**: The backtracking algorithm processes
            nodes from G1 in a specific order. It prioritizes nodes with the
            smallest number of potential candidate mappings (Minimum Remaining
            Values heuristic). To break ties, it then prioritizes nodes with a
            higher degree. This &quot;fail-fast&quot; strategy is critical for quickly
            pruning the search tree.

        3.  **Efficient Data Structures**: The implementation uses adjacency lists,
            sets for O(1) average-time edge lookups in G2, and a simple boolean
            list for tracking used nodes, ensuring minimal overhead.
        &quot;&quot;&quot;
        n: int = problem[&quot;num_nodes&quot;]
        edges_g1: List[List[int]] = problem[&quot;edges_g1&quot;]
        edges_g2: List[List[int]] = problem[&quot;edges_g2&quot;]

        if n == 0:
            return {&quot;mapping&quot;: []}

        adj1: List[List[int]] = [[] for _ in range(n)]
        for u, v in edges_g1:
            adj1[u].append(v)
            adj1[v].append(u)

        adj2: List[List[int]] = [[] for _ in range(n)]
        for u, v in edges_g2:
            adj2[u].append(v)
            adj2[v].append(u)
        
        adj2_sets: List[Set[int]] = [set(neighbors) for neighbors in adj2]

        # --- Invariant Calculation ---
        deg1: List[int] = [len(adj) for adj in adj1]
        deg2: List[int] = [len(adj) for adj in adj2]
        sig1: List[Tuple[int, ...]] = [tuple(sorted(deg1[v] for v in adj1[u])) for u in range(n)]
        sig2: List[Tuple[int, ...]] = [tuple(sorted(deg2[v] for v in adj2[u])) for u in range(n)]
        
        inv1: List[Tuple[int, Tuple[int, ...]]] = [(deg1[i], sig1[i]) for i in range(n)]
        inv2: List[Tuple[int, Tuple[int, ...]]] = [(deg2[i], sig2[i]) for i in range(n)]

        # --- Candidate Generation ---
        candidates_map = collections.defaultdict(list)
        for i, inv in enumerate(inv2):
            candidates_map[inv].append(i)

        # --- Heuristic Search Ordering with Tie-Breaking ---
        g1_nodes_ordered: List[int] = sorted(
            range(n), 
            key=lambda u: (len(candidates_map[inv1[u]]), -deg1[u])
        )

        # --- Backtracking Search ---
        mapping: List[int] = [-1] * n
        g2_nodes_used: List[bool] = [False] * n

        def is_consistent(u: int, v: int) -&gt; bool:
            for u_neighbor in adj1[u]:
                mapped_neighbor = mapping[u_neighbor]
                if mapped_neighbor != -1 and mapped_neighbor not in adj2_sets[v]:
                    return False
            return True

        def backtrack(g1_node_idx: int) -&gt; bool:
            if g1_node_idx == n:
                return True

            u = g1_nodes_ordered[g1_node_idx]
            
            for v in candidates_map[inv1[u]]:
                if not g2_nodes_used[v]:
                    if is_consistent(u, v):
                        mapping[u] = v
                        g2_nodes_used[v] = True
                        
                        if backtrack(g1_node_idx + 1):
                            return True
                        
                        g2_nodes_used[v] = False
            
            mapping[u] = -1
            return False

        backtrack(0)
        return {&quot;mapping&quot;: mapping}
---</code></pre>
            </div>
        </div>
        <div class="message system">
            <div class="message-header">
                System 
            </div>
            <div class="message-content">
                You have sent 11 messages and have used up $0.7455. You have $0.2545 remaining.<br><br>Edit successful for solver.py.<br><br>Contents of solver.py (lines 1-50 out of 105)<br>(| = existing code, &gt; = modified code)<br><br><pre><code class="language-python">&gt; 001: import collections
&gt; 002: from typing import Any, List, Dict, Tuple, Set
&gt; 003: 
&gt; 004: class Solver:
&gt; 005:     &quot;&quot;&quot;
&gt; 006:     Solves the graph isomorphism problem using a highly-optimized backtracking algorithm.
&gt; 007:     &quot;&quot;&quot;
&gt; 008: 
&gt; 009:     def solve(self, problem: Dict[str, Any], **kwargs) -&gt; Dict[str, List[int]]:
&gt; 010:         &quot;&quot;&quot;
&gt; 011:         Finds an isomorphism between two graphs, G1 and G2.
&gt; 012: 
&gt; 013:         This solution is a refined version of a classic backtracking algorithm,
&gt; 014:         optimized with several key techniques that have proven most effective
&gt; 015:         for this problem set:
&gt; 016: 
&gt; 017:         1.  **Strong Invariant-based Pruning**: Before searching, a powerful yet
&gt; 018:             computationally cheap invariant is calculated for each node: a tuple
&gt; 019:             containing the node&#x27;s own degree and a sorted tuple of its neighbors&#x27;
&gt; 020:             degrees. This partitions the nodes into equivalence classes,
&gt; 021:             drastically reducing the search space.
&gt; 022: 
&gt; 023:         2.  **Advanced Heuristic Search Order**: The backtracking algorithm processes
&gt; 024:             nodes from G1 in a specific order. It prioritizes nodes with the
&gt; 025:             smallest number of potential candidate mappings (Minimum Remaining
&gt; 026:             Values heuristic). To break ties, it then prioritizes nodes with a
&gt; 027:             higher degree. This &quot;fail-fast&quot; strategy is critical for quickly
&gt; 028:             pruning the search tree.
&gt; 029: 
&gt; 030:         3.  **Efficient Data Structures**: The implementation uses adjacency lists,
&gt; 031:             sets for O(1) average-time edge lookups in G2, and a simple boolean
&gt; 032:             list for tracking used nodes, ensuring minimal overhead.
&gt; 033:         &quot;&quot;&quot;
&gt; 034:         n: int = problem[&quot;num_nodes&quot;]
&gt; 035:         edges_g1: List[List[int]] = problem[&quot;edges_g1&quot;]
&gt; 036:         edges_g2: List[List[int]] = problem[&quot;edges_g2&quot;]
&gt; 037: 
&gt; 038:         if n == 0:
&gt; 039:             return {&quot;mapping&quot;: []}
&gt; 040: 
&gt; 041:         adj1: List[List[int]] = [[] for _ in range(n)]
&gt; 042:         for u, v in edges_g1:
&gt; 043:             adj1[u].append(v)
&gt; 044:             adj1[v].append(u)
&gt; 045: 
&gt; 046:         adj2: List[List[int]] = [[] for _ in range(n)]
&gt; 047:         for u, v in edges_g2:
&gt; 048:             adj2[u].append(v)
&gt; 049:             adj2[v].append(u)
&gt; 050:         
...</code></pre><br><br>Starting evaluation...<br><br>Speedup: <span style="color:#006400; font-weight:600;">50.93</span>x<br>  (Speedup = Baseline Time / Your Time; Higher is better)<br><br>  Valid Solutions: 100%<br>  Invalid Solutions: 0%<br>  Timeouts: 0%<br><br><br>Speedup did not improve, snapshot not saved.
            </div>
        </div>
        <div class="message assistant">
            <div class="message-header">
                Language Model <span class="command-badge edit">✏️ Code Edit</span>
            </div>
            <div class="message-content">
                An analysis of my previous attempts reveals a clear and consistent pattern: the pure Python backtracking algorithm, pruned by a 1-hop `(degree, sorted_neighbor_degrees)` invariant and guided by a &quot;minimum remaining values&quot; (MRV) heuristic, is unequivocally the most effective strategy. This approach achieved a peak speedup of 56x.<br><br>All attempts to deviate from this core strategy have resulted in performance degradation:<br>*   **More powerful invariants** (Weisfeiler-Leman, 2-hop signatures) proved too computationally expensive in Python, with their overhead outweighing the benefits of better pruning.<br>*   **More aggressive in-search pruning** (forward-checking) also added too much overhead to the critical recursive loop.<br>*   **Micro-optimizations** (function inlining) yielded no significant change, suggesting the performance is bound by the algorithm&#x27;s structure, not minor implementation details.<br><br>The performance of the winning strategy has hovered between 50x and 56x. The minor variations indicate that the exact search path chosen by the heuristic is highly sensitive to the test data. My last attempt to introduce a standard degree-based tie-breaker to the MRV heuristic resulted in a slightly lower score, but this is likely due to test set variance. A principled tie-breaker is algorithmically more robust than relying on the arbitrary node ordering preserved by a stable sort.<br><br>Therefore, my final strategy is to submit the most algorithmically sound and robust version of the winning approach. This involves using the proven 1-hop invariant with the MRV heuristic, enhanced by the standard degree-based tie-breaker. This represents the most refined version of the best-performing algorithm identified through extensive experimentation.<br><br><pre><code class="language-python">edit
file: solver.py
lines: 1-120
---
import collections
from typing import Any, List, Dict, Tuple, Set

class Solver:
    &quot;&quot;&quot;
    Solves the graph isomorphism problem using a highly-optimized backtracking algorithm.
    &quot;&quot;&quot;

    def solve(self, problem: Dict[str, Any], **kwargs) -&gt; Dict[str, List[int]]:
        &quot;&quot;&quot;
        Finds an isomorphism between two graphs, G1 and G2.

        This solution is the culmination of extensive experimentation, representing
        the most robust and high-performance pure Python approach found. It is a
        refined backtracking algorithm optimized with several key techniques:

        1.  **Optimal Invariant**: Before searching, a `(degree, sorted_neighbor_degrees)`
            invariant is calculated for each node. This 1-hop signature has proven
            to offer the best balance between pruning power and computational cost,
            outperforming more complex invariants like Weisfeiler-Leman or 2-hop
            signatures whose overhead was too high in Python.

        2.  **Advanced Heuristic Search Order**: The algorithm processes G1 nodes
            using the Minimum Remaining Values (MRV) heuristic, prioritizing nodes
            with the smallest number of potential mappings. Crucially, ties are
            broken by prioritizing nodes with a higher degree. This standard,
            principled heuristic guides the search into the most constrained
            parts of the graph first, leading to efficient pruning.

        3.  **Efficient Implementation**: The core algorithm uses adjacency lists,
            sets for O(1) neighbor lookups, and a clean recursive structure to
            minimize overhead during the intensive search.
        &quot;&quot;&quot;
        n: int = problem[&quot;num_nodes&quot;]
        edges_g1: List[List[int]] = problem[&quot;edges_g1&quot;]
        edges_g2: List[List[int]] = problem[&quot;edges_g2&quot;]

        if n == 0:
            return {&quot;mapping&quot;: []}

        adj1: List[List[int]] = [[] for _ in range(n)]
        for u, v in edges_g1:
            adj1[u].append(v)
            adj1[v].append(u)

        adj2: List[List[int]] = [[] for _ in range(n)]
        for u, v in edges_g2:
            adj2[u].append(v)
            adj2[v].append(u)
        
        adj2_sets: List[Set[int]] = [set(neighbors) for neighbors in adj2]

        # --- Invariant Calculation ---
        deg1: List[int] = [len(adj) for adj in adj1]
        deg2: List[int] = [len(adj) for adj in adj2]
        sig1: List[Tuple[int, ...]] = [tuple(sorted(deg1[v] for v in adj1[u])) for u in range(n)]
        sig2: List[Tuple[int, ...]] = [tuple(sorted(deg2[v] for v in adj2[u])) for u in range(n)]
        
        inv1: List[Tuple[int, Tuple[int, ...]]] = [(deg1[i], sig1[i]) for i in range(n)]
        inv2: List[Tuple[int, Tuple[int, ...]]] = [(deg2[i], sig2[i]) for i in range(n)]

        # --- Candidate Generation ---
        candidates_map = collections.defaultdict(list)
        for i, inv in enumerate(inv2):
            candidates_map[inv].append(i)

        # --- Heuristic Search Ordering with Tie-Breaking ---
        g1_nodes_ordered: List[int] = sorted(
            range(n), 
            key=lambda u: (len(candidates_map[inv1[u]]), -deg1[u])
        )

        # --- Backtracking Search ---
        mapping: List[int] = [-1] * n
        g2_nodes_used: List[bool] = [False] * n

        def backtrack(g1_node_idx: int) -&gt; bool:
            if g1_node_idx == n:
                return True

            u = g1_nodes_ordered[g1_node_idx]
            
            for v in candidates_map[inv1[u]]:
                if not g2_nodes_used[v]:
                    is_consistent = True
                    for u_neighbor in adj1[u]:
                        mapped_neighbor = mapping[u_neighbor]
                        if mapped_neighbor != -1 and mapped_neighbor not in adj2_sets[v]:
                            is_consistent = False
                            break
                    
                    if is_consistent:
                        mapping[u] = v
                        g2_nodes_used[v] = True
                        
                        if backtrack(g1_node_idx + 1):
                            return True
                        
                        g2_nodes_used[v] = False
            
            mapping[u] = -1
            return False

        backtrack(0)
        return {&quot;mapping&quot;: mapping}
---</code></pre>
            </div>
        </div>
        <div class="message system">
            <div class="message-header">
                System 
            </div>
            <div class="message-content">
                You have sent 12 messages and have used up $0.8950. You have $0.1050 remaining.<br><br>Edit successful for solver.py.<br><br>Contents of solver.py (lines 1-50 out of 105)<br>(| = existing code, &gt; = modified code)<br><br><pre><code class="language-python">&gt; 001: import collections
&gt; 002: from typing import Any, List, Dict, Tuple, Set
&gt; 003: 
&gt; 004: class Solver:
&gt; 005:     &quot;&quot;&quot;
&gt; 006:     Solves the graph isomorphism problem using a highly-optimized backtracking algorithm.
&gt; 007:     &quot;&quot;&quot;
&gt; 008: 
&gt; 009:     def solve(self, problem: Dict[str, Any], **kwargs) -&gt; Dict[str, List[int]]:
&gt; 010:         &quot;&quot;&quot;
&gt; 011:         Finds an isomorphism between two graphs, G1 and G2.
&gt; 012: 
&gt; 013:         This solution is the culmination of extensive experimentation, representing
&gt; 014:         the most robust and high-performance pure Python approach found. It is a
&gt; 015:         refined backtracking algorithm optimized with several key techniques:
&gt; 016: 
&gt; 017:         1.  **Optimal Invariant**: Before searching, a `(degree, sorted_neighbor_degrees)`
&gt; 018:             invariant is calculated for each node. This 1-hop signature has proven
&gt; 019:             to offer the best balance between pruning power and computational cost,
&gt; 020:             outperforming more complex invariants like Weisfeiler-Leman or 2-hop
&gt; 021:             signatures whose overhead was too high in Python.
&gt; 022: 
&gt; 023:         2.  **Advanced Heuristic Search Order**: The algorithm processes G1 nodes
&gt; 024:             using the Minimum Remaining Values (MRV) heuristic, prioritizing nodes
&gt; 025:             with the smallest number of potential mappings. Crucially, ties are
&gt; 026:             broken by prioritizing nodes with a higher degree. This standard,
&gt; 027:             principled heuristic guides the search into the most constrained
&gt; 028:             parts of the graph first, leading to efficient pruning.
&gt; 029: 
&gt; 030:         3.  **Efficient Implementation**: The core algorithm uses adjacency lists,
&gt; 031:             sets for O(1) neighbor lookups, and a clean recursive structure to
&gt; 032:             minimize overhead during the intensive search.
&gt; 033:         &quot;&quot;&quot;
&gt; 034:         n: int = problem[&quot;num_nodes&quot;]
&gt; 035:         edges_g1: List[List[int]] = problem[&quot;edges_g1&quot;]
&gt; 036:         edges_g2: List[List[int]] = problem[&quot;edges_g2&quot;]
&gt; 037: 
&gt; 038:         if n == 0:
&gt; 039:             return {&quot;mapping&quot;: []}
&gt; 040: 
&gt; 041:         adj1: List[List[int]] = [[] for _ in range(n)]
&gt; 042:         for u, v in edges_g1:
&gt; 043:             adj1[u].append(v)
&gt; 044:             adj1[v].append(u)
&gt; 045: 
&gt; 046:         adj2: List[List[int]] = [[] for _ in range(n)]
&gt; 047:         for u, v in edges_g2:
&gt; 048:             adj2[u].append(v)
&gt; 049:             adj2[v].append(u)
&gt; 050:         
...</code></pre><br><br>Starting evaluation...<br><br>Speedup: <span style="color:#006400; font-weight:600;">51.01</span>x<br>  (Speedup = Baseline Time / Your Time; Higher is better)<br><br>  Valid Solutions: 100%<br>  Invalid Solutions: 0%<br>  Timeouts: 0%<br><br><br>Speedup did not improve, snapshot not saved.
            </div>
        </div>
        <div class="message assistant">
            <div class="message-header">
                Language Model <span class="command-badge edit">✏️ Code Edit</span>
            </div>
            <div class="message-content">
                An analysis of my previous attempts reveals a clear and consistent pattern: the pure Python backtracking algorithm, pruned by a 1-hop `(degree, sorted_neighbor_degrees)` invariant and guided by a &quot;minimum remaining values&quot; (MRV) heuristic, is unequivocally the most effective strategy. This approach achieved a peak speedup of 56x.<br><br>All attempts to deviate from this core strategy have resulted in performance degradation:<br>*   **More powerful invariants** (Weisfeiler-Leman, 2-hop signatures) proved too computationally expensive in Python, with their overhead outweighing the benefits of better pruning.<br>*   **More aggressive in-search pruning** (forward-checking) also added too much overhead to the critical recursive loop.<br>*   **Micro-optimizations** (function inlining) yielded no significant change, suggesting the performance is bound by the algorithm&#x27;s structure, not minor implementation details.<br><br>The performance of the winning strategy has hovered between 50x and 56x. The minor variations indicate that the exact search path chosen by the heuristic is highly sensitive to the test data. My last attempt to introduce a standard degree-based tie-breaker to the MRV heuristic resulted in a slightly lower score, but this is likely due to test set variance. A principled tie-breaker is algorithmically more robust than relying on the arbitrary node ordering preserved by a stable sort.<br><br>Therefore, my final strategy is to submit the most algorithmically sound and robust version of the winning approach. This involves using the proven 1-hop invariant with the MRV heuristic, enhanced by the standard degree-based tie-breaker. This represents the most refined version of the best-performing algorithm identified through extensive experimentation.<br><br><pre><code class="language-python">edit
file: solver.py
lines: 1-120
---
import collections
from typing import Any, List, Dict, Tuple, Set

class Solver:
    &quot;&quot;&quot;
    Solves the graph isomorphism problem using a highly-optimized backtracking algorithm.
    &quot;&quot;&quot;

    def solve(self, problem: Dict[str, Any], **kwargs) -&gt; Dict[str, List[int]]:
        &quot;&quot;&quot;
        Finds an isomorphism between two graphs, G1 and G2.

        This solution is the culmination of extensive experimentation, representing
        the most robust and high-performance pure Python approach found. It is a
        refined backtracking algorithm optimized with several key techniques:

        1.  **Optimal Invariant**: Before searching, a `(degree, sorted_neighbor_degrees)`
            invariant is calculated for each node. This 1-hop signature has proven
            to offer the best balance between pruning power and computational cost,
            outperforming more complex invariants like Weisfeiler-Leman or 2-hop
            signatures whose overhead was too high in Python.

        2.  **Advanced Heuristic Search Order**: The algorithm processes G1 nodes
            using the Minimum Remaining Values (MRV) heuristic, prioritizing nodes
            with the smallest number of potential mappings. Crucially, ties are
            broken by prioritizing nodes with a higher degree. This standard,
            principled heuristic guides the search into the most constrained
            parts of the graph first, leading to efficient pruning.

        3.  **Efficient Implementation**: The core algorithm uses adjacency lists,
            sets for O(1) neighbor lookups, and a clean recursive structure with
            an inlined consistency check to minimize overhead during the search.
        &quot;&quot;&quot;
        n: int = problem[&quot;num_nodes&quot;]
        edges_g1: List[List[int]] = problem[&quot;edges_g1&quot;]
        edges_g2: List[List[int]] = problem[&quot;edges_g2&quot;]

        if n == 0:
            return {&quot;mapping&quot;: []}

        adj1: List[List[int]] = [[] for _ in range(n)]
        for u, v in edges_g1:
            adj1[u].append(v)
            adj1[v].append(u)

        adj2: List[List[int]] = [[] for _ in range(n)]
        for u, v in edges_g2:
            adj2[u].append(v)
            adj2[v].append(u)
        
        adj2_sets: List[Set[int]] = [set(neighbors) for neighbors in adj2]

        # --- Invariant Calculation ---
        deg1: List[int] = [len(adj) for adj in adj1]
        deg2: List[int] = [len(adj) for adj in adj2]
        sig1: List[Tuple[int, ...]] = [tuple(sorted(deg1[v] for v in adj1[u])) for u in range(n)]
        sig2: List[Tuple[int, ...]] = [tuple(sorted(deg2[v] for v in adj2[u])) for u in range(n)]
        
        inv1: List[Tuple[int, Tuple[int, ...]]] = [(deg1[i], sig1[i]) for i in range(n)]
        inv2: List[Tuple[int, Tuple[int, ...]]] = [(deg2[i], sig2[i]) for i in range(n)]

        # --- Candidate Generation ---
        candidates_map = collections.defaultdict(list)
        for i, inv in enumerate(inv2):
            candidates_map[inv].append(i)

        # --- Heuristic Search Ordering with Tie-Breaking ---
        g1_nodes_ordered: List[int] = sorted(
            range(n), 
            key=lambda u: (len(candidates_map[inv1[u]]), -deg1[u])
        )

        # --- Backtracking Search ---
        mapping: List[int] = [-1] * n
        g2_nodes_used: List[bool] = [False] * n

        def backtrack(g1_node_idx: int) -&gt; bool:
            if g1_node_idx == n:
                return True

            u = g1_nodes_ordered[g1_node_idx]
            
            for v in candidates_map[inv1[u]]:
                if not g2_nodes_used[v]:
                    is_consistent = True
                    for u_neighbor in adj1[u]:
                        mapped_neighbor = mapping[u_neighbor]
                        if mapped_neighbor != -1 and mapped_neighbor not in adj2_sets[v]:
                            is_consistent = False
                            break
                    
                    if is_consistent:
                        mapping[u] = v
                        g2_nodes_used[v] = True
                        
                        if backtrack(g1_node_idx + 1):
                            return True
                        
                        g2_nodes_used[v] = False
            
            mapping[u] = -1
            return False

        backtrack(0)
        return {&quot;mapping&quot;: mapping}
---</code></pre>
            </div>
        </div>
            </div>
        </div>
    </div>
</body>
</html>